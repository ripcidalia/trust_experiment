<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Trust Doors â€” jsPsych version</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://unpkg.com/jspsych@7.2.3/dist/css/jspsych.css" rel="stylesheet" />
  <style>
    body { margin:0; font-family: Arial, sans-serif; background:#f6f6f8; }
    #canvas-container { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    canvas { display:block; background:transparent; }
    .consent { padding:20px; max-width:900px; margin:30px auto; background:#fff; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.08); }
    .center { text-align:center; }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>

  <script src="https://unpkg.com/jspsych@7.2.3/dist/jspsych.js"></script>
  <script src="https://unpkg.com/jspsych@7.2.3/dist/plugins/jspsych-html-button-response.js"></script>
  <script src="https://unpkg.com/jspsych@7.2.3/dist/plugins/jspsych-html-slider-response.js"></script>

<script>
/* ==========================
   CONFIG - CHANGE THESE
   ==========================
   Put your assets in ./assets/
   Provide filenames below. For victims, list every file in the victims folder.
*/
const ASSET_DIR = "assets/";
const ASSETS = {
  bg: "background.png",
  door: "door.png",
  drone: "drone.png",
  left_arrow: "left_arrow.png",
  right_arrow: "right_arrow.png",
  empty: "empty.png"
};
// List all victim image files (relative to ASSET_DIR). Example:
const VICTIM_FILES = [
  "victims/v01.png",
  "victims/v02.png",
  "victims/v03.png"
];

// Original background pixel coordinates -> set these to your background's pixel coords
const COORDS_ARE_CENTER = false; // true if the coordinates below are centers, false if top-left
const ox_left = 479, oy_left = 248;
const ox_right = 1132, oy_right = 248;

// Experiment params
const NUM_TRIALS = 40;
const DRONE_ACCURACY = 0.75;
const HINGE_SIDE = "left"; // "left" or "right" (absolute hinge side)
const SHRINK_DURATION_MS = 450;
const SHRINK_MIN_WIDTH_PX = 8;

// Google Apps Script URL to POST logs to (optional). If empty, no server POST.
const GOOGLE_APPS_SCRIPT_URL = ""; // e.g. "https://script.google.com/macros/s/XXXX/exec"

/* ==========================
   END CONFIG
   ========================== */


// Utility: preload images and return mapping url->image element
async function preloadImages(urls){
  const images = {};
  await Promise.all(urls.map(u => new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = () => { images[u] = img; resolve(); };
    img.onerror = () => { console.warn("failed to load", u); resolve(); }; // resolve to continue even if missing
    img.src = u;
  })));
  return images;
}

// Helper to create an offscreen canvas scaled copy of an image
function scaleImageToCanvas(img, w, h){
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0,0, w,h);
  return c;
}

(async function main(){
  // make jsPsych
  const jsPsych = initJsPsych({
    display_element: document.getElementById('jspsych-target')
  });

  // Build list of all URLs to preload
  const urls = [];
  urls.push(ASSET_DIR + ASSETS.bg);
  urls.push(ASSET_DIR + ASSETS.door);
  urls.push(ASSET_DIR + ASSETS.drone);
  urls.push(ASSET_DIR + ASSETS.left_arrow);
  urls.push(ASSET_DIR + ASSETS.right_arrow);
  urls.push(ASSET_DIR + ASSETS.empty);
  VICTIM_FILES.forEach(f => urls.push(ASSET_DIR + f));

  const imgs = await preloadImages(urls);

  // Setup canvas and sizes to match display (use devicePixelRatio for crispness)
  const DPR = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const setCanvasSize = () => {
    const W = window.innerWidth;
    const H = window.innerHeight;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    canvas.width = Math.max(1, Math.round(W * DPR));
    canvas.height = Math.max(1, Math.round(H * DPR));
    ctx.setTransform(DPR,0,0,DPR,0,0); // so drawing uses CSS pixels
  };
  setCanvasSize();
  window.addEventListener('resize', setCanvasSize);

  // Precompute background scale & crop
  let bg_img_raw = imgs[ASSET_DIR + ASSETS.bg] || null;
  let bg_scale = null, bg_crop_x = 0, bg_crop_y = 0, scaled_bg_canvas = null;
  const screenW = () => window.innerWidth;
  const screenH = () => window.innerHeight;

  if (bg_img_raw){
    const iw = bg_img_raw.width, ih = bg_img_raw.height;
    const targetW = screenW(), targetH = screenH();
    const scale = Math.max(targetW / iw, targetH / ih);
    const new_w = Math.round(iw * scale), new_h = Math.round(ih * scale);
    bg_scale = scale;
    bg_crop_x = Math.floor((new_w - targetW) / 2);
    bg_crop_y = Math.floor((new_h - targetH) / 2);
    scaled_bg_canvas = scaleImageToCanvas(bg_img_raw, new_w, new_h);
  }

  // Scale other assets using bg_scale if present; otherwise scale by visual heuristics
  function scaledByBg(rawImg){
    if (!rawImg) return null;
    if (bg_scale !== null){
      const nw = Math.max(1, Math.round(rawImg.width * bg_scale));
      const nh = Math.max(1, Math.round(rawImg.height * bg_scale));
      return scaleImageToCanvas(rawImg, nw, nh);
    } else {
      // fallback: scale door to 60% screen height, scale others proportionally
      return scaleImageToCanvas(rawImg, Math.round(rawImg.width * (screenH()*0.6/rawImg.height)), Math.round(screenH()*0.6));
    }
  }

  const doorImgC = scaledByBg(imgs[ASSET_DIR + ASSETS.door]);
  const droneImgC = scaledByBg(imgs[ASSET_DIR + ASSETS.drone]);
  const leftArrowC = scaledByBg(imgs[ASSET_DIR + ASSETS.left_arrow]);
  const rightArrowC = scaledByBg(imgs[ASSET_DIR + ASSETS.right_arrow]);
  const emptyC = scaledByBg(imgs[ASSET_DIR + ASSETS.empty]);

  // scaled victim images list
  const victimCanvases = [];
  const victimFileNames = [];
  for (const vf of VICTIM_FILES){
    const raw = imgs[ASSET_DIR + vf];
    if (!raw) continue;
    let scaled = null;
    if (bg_scale !== null){
      scaled = scaleImageToCanvas(raw, Math.max(1, Math.round(raw.width * bg_scale)), Math.max(1, Math.round(raw.height * bg_scale)));
    } else {
      // fallback scale relative to door or screen
      const target_h = doorImgC ? Math.round(doorImgC.height * 0.30) : Math.round(screenH() * 0.12);
      const scale = target_h / raw.height;
      scaled = scaleImageToCanvas(raw, Math.max(1, Math.round(raw.width * scale)), Math.max(1, Math.round(raw.height * scale)));
    }
    victimCanvases.push(scaled);
    victimFileNames.push(vf);
  }

  // Drawer helpers
  const DOOR_W = doorImgC ? doorImgC.width : Math.round(screenW() * 0.22);
  const DOOR_H = doorImgC ? doorImgC.height : Math.round(screenH() * 0.60);

  // original->screen mapping (same math as Python)
  function originalToScreen(ox, oy){
    if (bg_scale === null) return [null, null];
    const sx = Math.round(ox * bg_scale - bg_crop_x);
    const sy = Math.round(oy * bg_scale - bg_crop_y);
    return [sx, sy];
  }

  let LEFT_DOOR_X, RIGHT_DOOR_X, DOOR_Y;
  if (bg_scale !== null){
    const [sx_left, sy_left] = originalToScreen(ox_left, oy_left);
    const [sx_right, sy_right] = originalToScreen(ox_right, oy_right);
    if (COORDS_ARE_CENTER){
      LEFT_DOOR_X = sx_left - Math.floor(DOOR_W / 2);
      DOOR_Y = sy_left - Math.floor(DOOR_H / 2);
      RIGHT_DOOR_X = sx_right - Math.floor(DOOR_W / 2);
    } else {
      LEFT_DOOR_X = sx_left;
      DOOR_Y = sy_left;
      RIGHT_DOOR_X = sx_right;
    }
  } else {
    // fallback margins
    const SIDE_MARGIN = Math.round(screenW() * 0.08);
    LEFT_DOOR_X = SIDE_MARGIN;
    RIGHT_DOOR_X = screenW() - SIDE_MARGIN - DOOR_W;
    DOOR_Y = Math.round((screenH() - DOOR_H) * 0.38);
  }
  // clamp
  LEFT_DOOR_X = Math.max(0, Math.min(LEFT_DOOR_X, screenW() - DOOR_W));
  RIGHT_DOOR_X = Math.max(0, Math.min(RIGHT_DOOR_X, screenW() - DOOR_W));
  DOOR_Y = Math.max(0, Math.min(DOOR_Y, screenH() - DOOR_H));

  // draw helpers
  function drawBackground(){
    if (scaled_bg_canvas){
      ctx.drawImage(scaled_bg_canvas, bg_crop_x, bg_crop_y, screenW(), screenH(), 0,0, screenW(), screenH());
    } else {
      ctx.fillStyle = '#cfe8ff';
      ctx.fillRect(0,0, screenW(), screenH());
    }
  }

  function drawDroneAndArrow(suggested_side){
    // drone
    const droneY = Math.round(screenH() * 0.08);
    if (droneImgC){
      const dw = droneImgC.width, dh = droneImgC.height;
      ctx.drawImage(droneImgC, Math.round(screenW()/2 - dw/2), Math.round(droneY - dh/2));
    } else {
      ctx.fillStyle = '#3ca0d0';
      ctx.beginPath(); ctx.ellipse(Math.round(screenW()/2), droneY, 40, 14, 0, 0, Math.PI*2); ctx.fill();
    }
    // arrow image
    const arrowGapY = Math.round(screenH() * 0.02);
    if (suggested_side === 'left'){
      if (leftArrowC){
        const aw = leftArrowC.width, ah = leftArrowC.height;
        const ax = LEFT_DOOR_X + Math.floor(DOOR_W/2) - Math.floor(aw/2);
        const ay = DOOR_Y - ah - arrowGapY;
        ctx.drawImage(leftArrowC, ax, ay);
      } else {
        // fallback triangle
        ctx.fillStyle = '#dc3c3c';
        ctx.beginPath(); ctx.moveTo(Math.round(screenW()/2 - 10), Math.round(droneY + 12)); ctx.lineTo(Math.round(screenW()/2 - screenW()*0.10), Math.round(droneY + 12)); ctx.lineTo(Math.round(screenW()/2 - screenW()*0.10 + 18), Math.round(droneY - 8)); ctx.fill();
      }
    } else {
      if (rightArrowC){
        const aw = rightArrowC.width, ah = rightArrowC.height;
        const ax = RIGHT_DOOR_X + Math.floor(DOOR_W/2) - Math.floor(aw/2);
        const ay = DOOR_Y - ah - arrowGapY;
        ctx.drawImage(rightArrowC, ax, ay);
      } else {
        ctx.fillStyle = '#dc3c3c';
        ctx.beginPath(); ctx.moveTo(Math.round(screenW()/2 + 10), Math.round(droneY + 12)); ctx.lineTo(Math.round(screenW()/2 + screenW()*0.10), Math.round(droneY + 12)); ctx.lineTo(Math.round(screenW()/2 + screenW()*0.10 - 18), Math.round(droneY - 8)); ctx.fill();
      }
    }
  }

  function drawDoorAt(x,y, imageCanvas){
    ctx.drawImage(imageCanvas, x, y);
  }

  function drawVictim(cx, cy, imgCanvas){
    if (imgCanvas){
      const vw = imgCanvas.width, vh = imgCanvas.height;
      ctx.drawImage(imgCanvas, Math.round(cx - vw/2), Math.round(cy - vh/2));
    } else {
      // fallback simple icon
      ctx.fillStyle = '#c83c3c';
      ctx.beginPath(); ctx.arc(cx, cy - 18, 18, 0, Math.PI*2); ctx.fill();
    }
  }

  // build jsPsych timeline
  const timeline = [];

  // Consent page (opening statement)
  const consent_html = `
    <div class="consent">
      <h2>Participant Information & Consent</h2>
      <p>This study investigates humanâ€“robot trust. Participation is voluntary and anonymous.</p>
      <p>Data will be recorded anonymously. You may stop at any time by closing this page. By pressing the button below you consent to participate.</p>
    </div>`;
  timeline.push({
    type: jsPsych.plugins['html-button-response'],
    stimulus: consent_html,
    choices: ["I consent and want to continue"]
  });

  // Slider question (0 never - 100 always)
  timeline.push({
    type: jsPsych.plugins['html-slider-response'],
    stimulus: '<h3>How much do you generally trust robots?</h3>',
    labels: ['0<br>(never)', '100<br>(always)'],
    min: 0, max: 100, start: 50
  });

  // Emergency question (yes/no style)
  timeline.push({
    type: jsPsych.plugins['html-button-response'],
    stimulus: '<h3>In an emergency situation, whose judgement do you generally trust more?</h3>',
    choices: ['My own judgement', 'A robot']
  });

  // A helper function to present a single trial using canvas and return trial data
  function makeTrial(trialIndex){
    return {
      type: 'call-function',
      func: () => new Promise(async (resolve) => {
        // Prepare per-trial randomization
        const victimSide = (Math.random() < 0.5) ? 'left' : 'right';
        const droneSuggested = (Math.random() < DRONE_ACCURACY) ? victimSide : (victimSide === 'left' ? 'right' : 'left');
        const droneCorrect = (droneSuggested === victimSide);

        // pick random victim skin for this trial
        let chosenVictimImg = null;
        let chosenVictimFilename = "";
        if (victimCanvases.length > 0){
          const idx = Math.floor(Math.random() * victimCanvases.length);
          chosenVictimImg = victimCanvases[idx];
          chosenVictimFilename = victimFileNames[idx];
        }

        // append the canvas to DOM (fullscreen)
        const container = document.createElement('div');
        container.id = 'canvas-container';
        container.style.position = 'fixed';
        container.style.top = '0'; container.style.left='0'; container.style.width='100%'; container.style.height='100%';
        container.style.zIndex = 99999;
        container.style.background = '#000000';
        container.appendChild(canvas);
        document.body.appendChild(container);

        // request fullscreen if not already (jsPsych can request but we'll attempt)
        if (document.fullscreenElement == null){
          try { await document.documentElement.requestFullscreen(); } catch(e){ /* ignore */ }
        }

        // show closed doors and drone until response
        let selection = null;
        let rt = null;
        let startTime = performance.now();
        function renderChoiceScreen(){
          // draw bg
          drawBackground();
          // title
          ctx.fillStyle = '#0b0b0b';
          ctx.font = `18px sans-serif`;
          ctx.fillText(`Trial ${trialIndex+1} / ${NUM_TRIALS}`, Math.round(screenW()/2 - 50), 30);
          // doors closed
          drawDoorAt(LEFT_DOOR_X, DOOR_Y, doorImgC);
          drawDoorAt(RIGHT_DOOR_X, DOOR_Y, doorImgC);
          // drone + arrow
          drawDroneAndArrow(droneSuggested);
          // hint
          ctx.font = `14px sans-serif`;
          ctx.fillStyle = '#101010';
          ctx.fillText("Press LEFT / RIGHT (or A / D) to choose", Math.round(screenW()/2 - 110), Math.round(screenH() - 30));
        }
        renderChoiceScreen();

        function onKeyChoice(e){
          const k = e.key.toLowerCase();
          if (k === 'arrowleft' || k === 'a'){
            selection = 'left';
          } else if (k === 'arrowright' || k === 'd'){
            selection = 'right';
          } else return;
          rt = (performance.now() - startTime) / 1000.0;
          window.removeEventListener('keydown', onKeyChoice);
          startShrinkAnimation(selection);
        }
        window.addEventListener('keydown', onKeyChoice);

        // Shrink animation
        async function startShrinkAnimation(chosen){
          // animation variables
          const chosen_x = (chosen === 'left') ? LEFT_DOOR_X : RIGHT_DOOR_X;
          const t0 = performance.now();

          return new Promise(resolveAnim => {
            function frame(now){
              const elapsed = now - t0;
              const tfrac = Math.min(1, elapsed / SHRINK_DURATION_MS);
              // new width interpolates from DOOR_W to SHRINK_MIN_WIDTH_PX
              const new_w = Math.max(1, Math.round(DOOR_W + (SHRINK_MIN_WIDTH_PX - DOOR_W) * tfrac));

              // blit frame
              drawBackground();
              // title
              ctx.fillStyle = '#0b0b0b'; ctx.font = `18px sans-serif`;
              ctx.fillText(`Trial ${trialIndex+1} / ${NUM_TRIALS}`, Math.round(screenW()/2 - 50), 30);

              // draw other door full size
              if (chosen === 'left'){
                drawDoorAt(RIGHT_DOOR_X, DOOR_Y, doorImgC);
              } else {
                drawDoorAt(LEFT_DOOR_X, DOOR_Y, doorImgC);
              }

              // draw victim (UNDER chosen door) from the start
              const vcx = chosen_x + Math.floor(DOOR_W / 2);
              const vcy = DOOR_Y + Math.floor(DOOR_H / 2) + Math.round(screenH()*0.02);
              if (victimSide === chosen){
                drawVictim(vcx, vcy, chosenVictimImg);
              } else {
                drawVictim(vcx, vcy, emptyC);
              }

              // draw drone & arrow (above)
              drawDroneAndArrow(droneSuggested);

              // compute blit_x depending on hinge side
              let blit_x = chosen_x;
              if (HINGE_SIDE.toLowerCase() === 'right'){
                blit_x = chosen_x + (DOOR_W - new_w);
              }
              // draw scaled door on top (occludes victim)
              // source crop width = new_w from doorImgC left or right depending on hinge
              if (HINGE_SIDE.toLowerCase() === 'left'){
                // take leftmost new_w columns of door image
                ctx.drawImage(doorImgC, 0, 0, new_w, DOOR_H, blit_x, DOOR_Y, new_w, DOOR_H);
              } else {
                // take rightmost new_w columns
                ctx.drawImage(doorImgC, DOOR_W - new_w, 0, new_w, DOOR_H, blit_x, DOOR_Y, new_w, DOOR_H);
              }

              // hinge edge visualization optional (not necessary)

              if (tfrac < 1.0){
                requestAnimationFrame(frame);
              } else {
                // small hold then resolve
                setTimeout(() => resolveAnim(), 650);
              }
            }
            requestAnimationFrame(frame);
          }).then(() => {
            // after animation ended
            // assemble trial result and post/log
            const participant_correct = (selection === victimSide);
            const trialResult = {
              trial: trialIndex+1,
              timestamp_utc: (new Date()).toISOString(),
              victim_side: victimSide,
              drone_suggested: droneSuggested,
              drone_correct: droneCorrect,
              participant_choice: selection,
              participant_correct: participant_correct,
              reaction_time_s: rt,
              drone_accuracy_setting: DRONE_ACCURACY,
              hinge_side: HINGE_SIDE,
              screen_width: screenW(),
              screen_height: screenH(),
              pre_trust_slider: jsPsych.data.get().last(2).values()[0].response, // slider trial is earlier: careful indexing
              pre_emergency_pref: jsPsych.data.get().last(1).values()[0].button_pressed,
              bg_filename: ASSETS.bg || "",
              door_filename: ASSETS.door || "",
              drone_filename: ASSETS.drone || "",
              chosen_victim_filename: chosenVictimFilename || "",
              empty_filename: ASSETS.empty || "",
              bg_scale: bg_scale || "",
              bg_crop_x: bg_crop_x || "",
              bg_crop_y: bg_crop_y || "",
              ox_left, oy_left, ox_right, oy_right,
              left_door_screen_x: LEFT_DOOR_X,
              left_door_screen_y: DOOR_Y,
              right_door_screen_x: RIGHT_DOOR_X,
              right_door_screen_y: DOOR_Y
            };

            // push to jsPsych data
            jsPsych.data.addDataToLastTrial(trialResult);

            // optionally POST to Google Apps Script
            if (GOOGLE_APPS_SCRIPT_URL){
              fetch(GOOGLE_APPS_SCRIPT_URL, {
                method: 'POST',
                mode: 'cors',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(trialResult)
              }).catch(err => console.warn("Failed to POST log:", err));
            }

            // remove canvas and exit fullscreen
            try { if (document.fullscreenElement) document.exitFullscreen(); } catch(e){}
            if (container && container.parentNode) container.parentNode.removeChild(container);

            resolve(trialResult);
            resolve(); // resolve the call-function promise
          });
        } // end startShrinkAnimation
      }) // end promise
    } // end func
  } // end makeTrial

  // Add trials to timeline
  for (let i=0; i<NUM_TRIALS; i++){
    timeline.push(makeTrial(i));
  }

  // On finish: offer to download csv
  timeline.push({
    type: jsPsych.plugins['html-button-response'],
    stimulus: '<h2>Experiment complete â€” thank you!</h2><p>You may now close this page.</p>',
    choices: ['Download data as CSV']
  });

  jsPsych.init({
    timeline: timeline,
    on_finish: function(){
      // download CSV
      const csv = jsPsych.data.get().csv();
      const blob = new Blob([csv], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'trust_doors_data.csv';
      a.click();
      URL.revokeObjectURL(url);
    }
  });

})();
</script>
</body>
</html>
