<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Trust Doors — Web Version (Reworked)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <!-- Optional: if you later ship a manifest and want standalone on iOS home screen -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">


    <!-- Local jsPsych files (adjust paths if your vendor folder differs) -->
    <script src="jspsych/jspsych.js"></script>
    <script src="jspsych/plugin-html-slider-response.js"></script>
    <script src="jspsych/plugin-html-button-response.js"></script>
    <script src="jspsych/plugin-html-keyboard-response.js"></script>
    <script src="jspsych/plugin-fullscreen.js"></script>

    <script src="js/conditions.js"></script>

    <link href="jspsych/jspsych.css" rel="stylesheet" type="text/css" />

    <style>
      :root { --bg: #f4f6fb; --card: #ffffff; --accent: #2b6fbf; --muted:#666; --safe-top: env(safe-area-inset-top, 0px); --safe-bottom: env(safe-area-inset-bottom, 0px); }

      /* Fill the *visible* viewport on mobile and desktop */
      html, body {
        margin: 0;
        font-family: system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
        background: var(--bg);
        height: 100svh;   /* fallback for older Safari */
        height: 100dvh;   /* preferred: visible viewport height */
      }

      /* The jsPsych container pins to the safe top/bottom (prevents cropping under URL bar/notch) */
      #jspsych-target {
        position: fixed;
        left: 0; right: 0;
        top: var(--safe-top);
        bottom: var(--safe-bottom);
        width: 100%;
        height: auto;     /* height controlled by top/bottom */
      }

      
      .center-outer { min-height:100vh; min-height:100svh; display:flex; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; }
      .card { background:var(--card); border-radius:10px; box-shadow:0 8px 30px rgba(10,10,20,0.08); padding:28px; width:100%; max-width:900px; }
      h1 { margin:0 0 12px 0; font-size:22px; }
      p { color:var(--muted); line-height:1.45; }
      #consent-button { margin-top:18px; padding:12px 20px; background:var(--accent); color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer; }
      .two-line-label { text-align:center; font-size:14px; line-height:1.1; }

      /* --- scene styling --- */
      /* Scene fills visible viewport, with safe-area padding */
      .scene-root {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100svh;
        height: 100dvh;
        margin: 0;
        padding-top: var(--safe-top);
        padding-bottom: var(--safe-bottom);
        background: #000;
        overflow: hidden;
      }
      .scene-frame { position:relative; width:100vw; max-width:100vw; line-height:0; overflow:visible; }
      .background { width:100%; height:auto; display:block; user-select:none; -webkit-user-drag:none; z-index:0 }

      /* make doors tappable; keep inner assets non-interactive */
      .overlay { position:absolute; z-index:2; overflow:visible; pointer-events:auto; }
      .overlay .door-image { width:100%; height:100%; display:block; object-fit:contain; user-select:none; -webkit-user-drag:none; transform-origin:left center; transition: transform 0.55s cubic-bezier(.2,.9,.1,1); pointer-events:none; }
      /* door-open triggers horizontal shrink (hinge at left) */
      .door-open { transform: scaleX(0); }

      @keyframes droneHover {
        0%   { --hoverY: 0px; }
        50%  { --hoverY: var(--hover-amp, 4px); }
        100% { --hoverY: 0px; }
      }

      .overlay-drone.hovering {
        animation: droneHover var(--hover-period, 1600ms) ease-in-out infinite;
        animation-fill-mode: both; /*  keep last keyframe when paused */
      }


      /* lets us pause the hover when the drone is in transit */
      .overlay-drone.hovering.paused {
        animation-play-state: paused;
      }

      
      /* --- thinking sensor cone (cool cyan, soft falloff, subtle grid) --- */
      .scan-cone{
        position:absolute;
        z-index:3;                 /* below .overlay-drone (4), above doors (2) */
        pointer-events:none;
        opacity:0;                 /* JS fades it in/out */
        transition: opacity 140ms ease;
        transform-origin: 50% 0%;  /* apex at top center */
        clip-path: polygon(50% 0%, 10% 100%, 90% 100%); /* triangle */
        mix-blend-mode: screen;    /* HUD-ish blend on dark bg */
        /* width/height/left/top are set from JS per scene */
        will-change: transform, opacity;
      }

      /* cyan gradient fill (less flashlight-y) */
      .scan-cone::before{
        content:"";
        position:absolute;
        inset:0;
        background:
          linear-gradient(
            to bottom,
            rgba(90,210,255,0.55) 0%,
            rgba(90,210,255,0.28) 35%,
            rgba(90,210,255,0.12) 70%,
            rgba(90,210,255,0.00) 100%
          );
        filter: blur(0.2px);
      }

      /* faint grid to imply sampling */
      .scan-cone .grid{
        position:absolute;
        inset:0;
        background:
          repeating-linear-gradient(
            to right,
            rgba(150,220,255,0.12) 0 1px,
            transparent 1px 10px
          ),
          repeating-linear-gradient(
            to bottom,
            rgba(150,220,255,0.10) 0 1px,
            transparent 1px 10px
          );
        opacity: 0.35;
        clip-path: inherit;
      }

      .decision-flash { animation: decisionFlash 150ms ease-in-out; }
      @keyframes decisionFlash {
        0%   { filter: brightness(1) saturate(1); }
        40%  { filter: brightness(1.2) saturate(1.05); } /* gentle */
        100% { filter: brightness(1) saturate(1); }
      }


      .revealed-image { position:absolute; z-index:1; top:0; left:0; width:100%; height:100%; display:block; object-fit:contain; }

      /* === Foreground FX (smoke + fire) === */
      .fx-layer{
        position: absolute;
        top: 0; left: 0;
        pointer-events: none;
        user-select: none;
        will-change: transform, opacity, left, top;
        visibility: visible;
        opacity: 1;
        transform: translateZ(0);
        will-change: transform;
      }

      /* Layering: above drone (z=4), below decision HUD (z=8) */
      .smoke-left, .smoke-right { z-index: 46; opacity: .95; }
      .fire-left,  .fire-right  { z-index: 47; opacity: 1}


      .overlay-drone {
        position: absolute;
        z-index: 4;
        user-select: none;
        -webkit-user-drag: none;
        visibility: visible;
        pointer-events: none;
        --hover-amp: 8px; /* can be overridden from JS */
        display: inline-block;
        perspective: 800px;
        transform: translate3d(var(--tx, 0px), var(--ty, 0px), 0) translateY(var(--hoverY, 0px));
        will-change: transform;
        transition: none;
      }

      .overlay-drone .drone-body {
        display: block;
        width: 100%;                    /* body scales with the container */
        height: auto;
      }

      /* Each rotor is a container that holds the perspective tilt.
      We DON'T animate this element's transform. */
      .overlay-drone .rotor {
        position: absolute;
        width: 23%;                  /* horizontal span relative to drone width */
        height: 5%;                  /* vertical compression (flat ellipse)    */
        top: 3.8%;
        pointer-events: none;
        transform-origin: 50% 50%;
        /* slight squash to enhance “seen from eye level” */
        transform: rotateX(72deg) scaleY(0.9);
      }

      /* Side-specific yaw so the hubs aim slightly outward (like a real quad) */
      .overlay-drone .rotor-left  { left: 26.6%;  transform: rotateX(72deg) rotateY(0deg) scaleY(0.9); }
      .overlay-drone .rotor-right { right: 26.6%; transform: rotateX(72deg) rotateY(0deg) scaleY(0.9); }

      /* Denser, less translucent rotor disc */
      .overlay-drone .rotor .disc {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 50%;

        /* almost opaque now */
        opacity: 1;
        filter: blur(3px);
        mix-blend-mode: normal;

        /* base tint + brighter gradient layers for solid look */
        background:
          radial-gradient(ellipse at center,
            rgba(235,245,255,0.9) 18%,
            rgba(200,220,255,0.85) 45%,
            rgba(170,195,245,0.75) 70%,
            rgba(130,160,230,0.6) 85%,
            rgba(80,100,150,0.4) 95%),
            linear-gradient(to bottom, rgba(255,255,255,0.15), rgba(0,0,0,0.1)),
          #7382a8; /* solid fallback color */

        /* stronger rim and depth */
        box-shadow:
          inset 0 0 0 1px rgba(255,255,255,0.45),
          inset 0 0 12px rgba(200,220,255,0.45),
          0 0 6px rgba(80,100,160,0.35);

        animation: propSpin 58ms linear infinite;
      }


      /* Faint blade streaks that rotate with the disc */
      .overlay-drone .rotor .disc::before {
        content: "";
        position: absolute; inset: 0;
        border-radius: 50%;
        /* four soft streaks + gaps; parent rotation animates them */
        background:
          conic-gradient(
            from 0deg,
            rgba(255,255,255,0.35) 0 6deg, transparent 6deg 24deg,
            rgba(255,255,255,0.35) 24deg 30deg, transparent 30deg 48deg,
            rgba(255,255,255,0.35) 48deg 54deg, transparent 54deg 72deg,
            rgba(255,255,255,0.35) 72deg 78deg, transparent 78deg 96deg
          );
        filter: blur(0.6px);
        opacity: 0.7;
      }

      /* Visible hub so the disc reads as a physical part */
      .overlay-drone .rotor .disc::after {
        content: "";
        position: absolute;
        left: 50%; top: 50%;
        width: 22%; height: 22%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background:
          radial-gradient(circle at 48% 52%, #e6eeff 0%, #a9b8e6 60%, #7c8bb3 100%);
        box-shadow:
          0 0 2px rgba(0,0,0,0.5),
          inset 0 0 3px rgba(255,255,255,0.6);
        opacity: 0.95;
      }


      /* Spin only the child, never the parent (so perspective stays intact) */
      @keyframes propSpin {
        from { transform: rotate(0deg); }
        to   { transform: rotate(360deg); }
      }

      /* === Mission Outcome Panel (taller, centered) === */
      .mission-panel {
        position: absolute;
        z-index: 60;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -46%) scale(.985);

        width: min(520px, 92vw);
        min-height: 160px;              /*  taller box */
        padding-top: 20px;
        padding-bottom: 40px;

        display: flex;                  /*  vertical centering */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 35px;                      /*  space between badge and title */

        border-radius: 16px;
        background: rgba(12,16,24,.80);
        color: #eaf2ff;
        border: 1px solid rgba(150,190,255,.22);
        backdrop-filter: blur(8px);
        box-shadow:
          0 18px 48px rgba(0,0,0,.42),
          inset 0 0 0 1px rgba(255,255,255,.04);

        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 220ms ease, transform 220ms cubic-bezier(.2,.9,.1,1);
        box-sizing: border-box;
      }

      .mission-panel.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
      }

      /* Badge ABOVE title */
      .mission-panel .mp-badge {
        display: inline-block;
        padding: 16px 20px;
        border-radius: 999px;
        font-size: 26px;
        font-weight: 900;
        letter-spacing: .7px;
        color: #0b111a;
        box-shadow: 0 2px 10px rgba(0,0,0,.2), inset 0 -1px 0 rgba(255,255,255,.3);
        margin-bottom: 0px;       /* extra separation from the title */
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }

      .mission-panel .mp-title {
        font-size: 40px;
        font-weight: 900;
        letter-spacing: .5px;
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }

      /* Color variants */
      .mission-panel.is-success .mp-badge { background: #98ffd5; }
      .mission-panel.is-fail    .mp-badge { background: #ffb0b6; }

      /* Fullscreen blackout layer used between trials */
      #blackout{
        position:fixed; inset:0; z-index:10020; background:#000;
        opacity:0; pointer-events:none; transition:opacity 450ms ease;
      }
      #blackout.show{ opacity:1; }
      #blackout .blackout-text{
        position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
        color:#9fb7ff; font-weight:800; letter-spacing:.6px; opacity:.85;
        text-align:center; font-size:22px;
      }


      .trial-counter {
        /* put it under the fixed Exit button (top-right) */
        position: fixed;
        top: calc(var(--safe-top) + 12px + 46px + 6px); /* Exit top + button height (~36px) + small gap */
        right: 12px;

        /* unset the old centering */
        left: auto;
        transform: none;

        z-index: 10011; /* just above the Exit button’s 10010 to avoid overlap issues */
        color: #fff;
        font-size: 22px;
        font-weight: 700;
        letter-spacing: .5px;
        text-shadow: 0 2px 6px rgba(0,0,0,.6);
        user-select: none;
        -webkit-user-select: none;
        pointer-events: none;
        display: inline-flex;
        align-items: baseline;
        gap: 6px;
      }

      .trial-counter .tc-label { opacity: .9; font-weight: 800; letter-spacing: .3px; }
      .trial-counter .tc-of    { opacity: .8; font-weight: 600; }
      .trial-counter .tc-index,
      .trial-counter .tc-total { font-weight: 800; }

      /* Countdown HUD (appears during decision phase only) */
      .countdown-hud {
        position: fixed;
        top: calc(var(--safe-top) + 12px + 46px + 6px + 32px); /* just under the trial counter */
        right: 12px;
        z-index: 10011;
        background: rgba(12,16,24,.78);
        color: #d9e6ff;
        border: 1px solid rgba(120,180,255,.25);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: .3px;
        backdrop-filter: blur(6px);
        box-shadow: 0 6px 22px rgba(0,0,0,.28), inset 0 0 0 1px rgba(255,255,255,.04);
        display: none; /* JS toggles on */
      }
      .countdown-hud.low { color:#ffd966; }   /* last 2s */
      .countdown-hud.critical { color:#ff5c67; } /* last 1s */


      /* Decision box: lives inside .scene-frame, positioned near doors; expands upward */
      #decision-box{
        position: absolute;            
        left: 50%;                     
        transform: translateX(-50%);  
        transform-origin: 50% 100%;    

        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        padding: 12px 14px;

        background: rgba(12,16,24,.68);
        color: #d9e6ff;
        border: 1px solid rgba(120,180,255,.25);
        border-radius: 12px;
        backdrop-filter: blur(6px);
        --glow-color: hsl(205 90% 60% / 0.25);
        --glow-strong-color: hsl(205 90% 60% / 0.45);
        box-shadow:
          0 12px 40px rgba(0,0,0,.35),
          inset 0 0 0 1px rgba(255,255,255,.04),
          0 0 16px 4px var(--glow-color);
        z-index: 50;

        width: min(520px, 92vw);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        will-change: max-height, opacity, transform;
        overflow: hidden; /* ensures height clamps cleanly while animating */

        /* we animate opacity + height for compact→expanded */
        max-height: 999px; /* will clamp via mode classes below */
        transition:
          box-shadow 140ms linear,
          opacity 220ms ease,
          transform 220ms ease,
          max-height 260ms cubic-bezier(.2,.9,.1,1),
          visibility 0s linear 220ms;
      }

      #decision-box.hud-show{
        opacity: 1;
        transform: translateX(-50%);
        visibility: visible;
        pointer-events: auto;
        transition:
          opacity 220ms ease,
          transform 220ms ease,
          max-height 260ms cubic-bezier(.2,.9,.1,1),
          visibility 0s;
      }

      /* closing pose: tilt/settle a touch while fading */
      #decision-box.hud-closing{
        opacity: 0;
        transform: translateX(-50%) translateY(6px) scale(0.985);
        transition:
          opacity 220ms ease,
          transform 220ms ease,
          max-height 200ms ease; /* optional: let the height ease a bit too */
      }

      /* while closing, keep visibility on so the fade can run */
      #decision-box.hud-show.hud-closing{
        visibility: visible;
      }


      /* COMPACT mode: bar-only (label + meter) */
      #decision-box.compact{
        max-height: 64px;          /* ~bar height; adjust if your fonts differ */
      }

      /* EXPANDED mode: show controls; grows upward from same baseline */
      #decision-box.expanded{
        max-height: 320px;
      }

      /* Initial: hidden, slightly lifted & smaller (so expansion reverses nicely) */
      #decision-box .decision-controls,
      #decision-box #decision-text {
        overflow: hidden;
        max-height: 0;
        opacity: 0;
        transform: translateY(-6px) scale(.98);
        transition:
          max-height 320ms cubic-bezier(.2,.9,.1,1),
          opacity 260ms ease,
          transform 320ms cubic-bezier(.2,.9,.1,1);
        will-change: max-height, opacity, transform;
      }

      /* Expanded: reveal & settle */
      #decision-box.expanded .decision-controls,
      #decision-box.expanded #decision-text {
        max-height: 500px;   /* > content height */
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      /* Optional: tiny stagger so the text settles before the buttons */
      #decision-box.reveal-stagger.expanded #decision-text {
        transition-delay: 0ms, 0ms, 0ms;          /* no delay for the label */
      }
      #decision-box.reveal-stagger.expanded .decision-controls {
        transition-delay: 60ms, 60ms, 60ms;       /* buttons trail slightly */
      }


      /* keep your existing reduced-motion rule consistent */
      @media (prefers-reduced-motion: reduce) {
        #decision-box{ transition: none; transform: translateX(-50%); }
        #decision-box.hud-show{ transition: none; }
      }

      /* (retain your other button/text styles below this unchanged) */




      #decision-box p {
        margin: 0 0 6px 0;           /* label above buttons */
        font-size: 15px;
        font-weight: 600;
        letter-spacing: .2px;
        color: #b6c7e6;
        text-align: center;          /* ⬅️ center the copy */
      }


      #decision-box .primaryBtn,
      #decision-box .secondaryBtn {
        appearance: none;
        width: 100%;                 /* ⬅️ full-width buttons */
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 700;
        border-radius: 10px;
        cursor: pointer;

        background: radial-gradient(120% 120% at 50% 0%, rgba(43,129,255,.22), rgba(43,129,255,.06));
        color: #d9e6ff;
        border: 1px solid rgba(12, 23, 39, 0.55);
        box-shadow: 0 4px 14px rgba(0,0,0,.12);
        transition: transform .04s ease, filter .15s ease, background .15s ease, border-color .15s ease;
      }

      /* Optional tighter spacing on very small screens */
      @media (max-width: 680px) {
        #decision-box { gap: 8px; padding: 10px 12px; }
      }

      /* Hover/active/focus states */
      #decision-box .primaryBtn:hover,
      #decision-box .secondaryBtn:hover {
        filter: brightness(1.08);
      }
      #decision-box .primaryBtn:active,
      #decision-box .secondaryBtn:active {
        transform: translateY(1px);
      }
      #decision-box .primaryBtn:focus-visible,
      #decision-box .secondaryBtn:focus-visible {
        outline: 2px solid rgba(120,180,255,.65);
        outline-offset: 2px;
      }

      /* Slightly tighter on very small screens */
      @media (max-width: 680px) {
        #decision-box { gap: 8px; padding: 10px 12px; }
      }

      /* --- Environmental Integrity (in-decision-box) --- */
      .env-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .env-label {
        font-size: 13px;
        font-weight: 700;
        letter-spacing: .2px;
        color: #b6c7e6;
        white-space: nowrap;
      }
      .env-wrap {
        position: relative;
        flex: 1;
        height: 14px;
        border-radius: 999px;
        background: rgba(180,200,235,.15);
        box-shadow: inset 0 0 0 1px rgba(120,180,255,.18);
        overflow: hidden;
      }
      .env-fill {
        position: absolute;
        inset: 0;
        width: 100%;
        transform-origin: left center;
        transform: scaleX(1); /* JS animates 1 -> 0 */
        background: hsl(205 70% 50%); /* JS will override color via HSL */
        transition: filter 140ms ease;
      }
      .env-pct {
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        font-weight: 700;
        opacity: .85;
        min-width: 3ch;
        text-align: right;
      }

      /* subtle pulse when integrity < ~30% */
      @keyframes envPulse {
        0%   { filter: brightness(1) saturate(1); }
        50%  { filter: brightness(1.12) saturate(1.06); }
        100% { filter: brightness(1) saturate(1); }
      }
      .env-fill.pulse {
        animation: envPulse 900ms ease-in-out infinite;
      }

      /* --- Decision box heartbeat (sync with env red-zone) --- */
      @keyframes boxHeartbeat {
        0%, 100% {
          box-shadow:
            0 12px 40px rgba(0,0,0,.35),
            inset 0 0 0 1px rgba(255,255,255,.04),
            /* zero spread = invisible, keeps color consistent */
            0 0 0 0 var(--glow-strong-color);
        }
        50% {
          box-shadow:
            0 12px 40px rgba(0,0,0,.45),
            inset 0 0 0 1px rgba(255,255,255,.05),
            0 0 28px 10px var(--glow-strong-color);
        }
      }


      #decision-box.heartbeat {
        /* period comes from JS via --hb-period */
        animation: boxHeartbeat var(--hb-period, 900ms) ease-in-out infinite;
      }

      /* Respect reduced motion */
      @media (prefers-reduced-motion: reduce) {
        #decision-box.heartbeat { animation: none; }
      }


      /* === Scene warmth (true color overlays; no hue-rotate) === */
      .scene-root::after{
        content:"";
        position:absolute; inset:0;
        pointer-events:none;
        z-index: 100;
        /* the overlay is a soft radial tint near the lower area */
        background:
          radial-gradient(
            140% 120% at 50% 82%,
            var(--warmth-color, rgba(255,140,60,0.20)) 0%,
            rgba(0,0,0,0) 62%
          );
        mix-blend-mode: screen;       /* preserves orange fire; avoids pinking */
        opacity: var(--warmth-base, 0);             /* base strength */
        transition: opacity 240ms ease;             /* fade when class changes */
      }

      /* Defaults; JS sets --hb-period when flickering is enabled */
      .scene-root { --warmth-base: 0; --warmth-peak: 0; }

      /* Flicker uses your existing animation timing variable */
      @keyframes warmthFlicker {
        0%, 100% { opacity: var(--warmth-base); }
        50%      { opacity: var(--warmth-peak); }
      }
      .scene-root.warmth-flicker::after {
        animation: warmthFlicker var(--hb-period, 900ms) ease-in-out infinite;
      }

      /* Cool (bluish) – gentler opacity so it doesn’t wash out */
      .scene-root.warmth-cool  { 
        --warmth-color: rgba(70, 140, 255, 0.22);   /* cool blue */
        --warmth-base:  0.25;
        --warmth-peak:  0.38;
      }

      /* Warm (light orange) */
      .scene-root.warmth-warm  { 
        --warmth-color: rgba(255, 150, 80, 0.28);   /* warm orange */
        --warmth-base:  0.25;
        --warmth-peak:  0.38;
      }

      /* Hot (stronger orange/red) */
      .scene-root.warmth-hot   { 
        --warmth-color: rgba(255, 100, 40, 0.35);   /* hot orange/red */
        --warmth-base:  0.45;
        --warmth-peak:  0.55;
      }

      /* Respect reduced motion (no flicker animation) */
      @media (prefers-reduced-motion: reduce) {
        .scene-root.warmth-flicker::after { animation: none; }
      }


      @property --hoverY {
        syntax: '<length>';
        inherits: false;
        initial-value: 0px;
      }


      /* === Camera shake (risk-driven) === */
      @keyframes camShake {
        0%   { transform: translate3d(0, 0, 0); }
        10%  { transform: translate3d(calc(var(--shake-amp, 0px) *  0.8), calc(var(--shake-amp, 0px) * -0.3), 0); }
        20%  { transform: translate3d(calc(var(--shake-amp, 0px) * -0.6), calc(var(--shake-amp, 0px) *  0.5), 0); }
        30%  { transform: translate3d(calc(var(--shake-amp, 0px) *  0.4), calc(var(--shake-amp, 0px) *  0.2), 0); }
        40%  { transform: translate3d(calc(var(--shake-amp, 0px) * -0.4), calc(var(--shake-amp, 0px) * -0.4), 0); }
        50%  { transform: translate3d(calc(var(--shake-amp, 0px) *  0.3), calc(var(--shake-amp, 0px) *  0.6), 0); }
        60%  { transform: translate3d(calc(var(--shake-amp, 0px) * -0.2), calc(var(--shake-amp, 0px) * -0.2), 0); }
        70%  { transform: translate3d(calc(var(--shake-amp, 0px) *  0.6), calc(var(--shake-amp, 0px) *  0.1), 0); }
        80%  { transform: translate3d(calc(var(--shake-amp, 0px) * -0.5), calc(var(--shake-amp, 0px) *  0.5), 0); }
        90%  { transform: translate3d(calc(var(--shake-amp, 0px) *  0.2), calc(var(--shake-amp, 0px) * -0.3), 0); }
        100% { transform: translate3d(0, 0, 0); }
      }

      /* attach to the visual frame only (not the whole page) */
      .scene-frame.risk-shake {
        animation: camShake var(--shake-period, 900ms) ease-in-out infinite;
        will-change: transform;
      }


      /* Exit button */
      #exit-btn {
        position: fixed; top: 12px; right: 12px; z-index: 20060;
        padding: 8px 12px; border-radius: 8px; border: none; cursor: pointer;
        background: #333; color: #fff; font-weight: 600; opacity: 0.85;
      }
      #exit-btn:hover { opacity: 1; }

      /* Modal */
      .modal-overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,.6);
        display: none; align-items: center; justify-content: center; z-index: 20050;
      }
      .modal-card {
        width: 92%; max-width: 520px; background: #fff; border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,.25); padding: 22px;
        font-family: system-ui, Segoe UI, Roboto, Arial;
      }
      .modal-card h3 { margin: 0 0 8px 0; font-size: 20px; }
      .modal-card p { margin: 0 0 18px 0; color: #333; }
      .modal-actions { display: flex; gap: 10px; flex-wrap: wrap; }
      .modal-actions button {
        flex: 1; padding: 10px 12px; border-radius: 10px; border: none; cursor: pointer; font-weight: 700;
      }
      .btn-secondary { background:#eee; color:#333; }
      .btn-danger { background:#ff5c67; color:#fff; }
      .btn-primary { background:#2b6fbf; color:#fff; }

      /* Only force black between trials during the main task (prevents white flicker on feedback->door only) */
      body.task-dark #jspsych-target,
      body.task-dark .jspsych-display-element,
      body.task-dark .jspsych-content-wrapper {
        background: #000 !important;
      }
      /* Reduce iOS scroll/zoom quirks */
      * { -webkit-tap-highlight-color: transparent; }
      html, body { overscroll-behavior: none; touch-action: manipulation; }

      /* Make the root scene fill the safe viewport cleanly */
      .scene-root { width:100vw; height:100svh; }

      /* Small tweak so the mobile choice bar doesn't overlap higher z-index content */
      #mobile-choices { backdrop-filter: blur(6px); background: rgba(0,0,0,.35); }
      #mob-left, #mob-right { background:#fff; }

    </style>
  </head>

  <body>  
    <!-- Consent UI (shown first) -->
    <div id="consent-screen" class="center-outer">
      <div class="card">
        <h1>Participant Information & Consent</h1>
        <p>
          You are being invited to participate in a research study titled 
          <strong>Trust in Human–Robot Interaction in Search-and-Rescue Scenarios</strong>. 
          This study is being conducted by Pedro Rodrigues Correia da Silva from the 
          Faculty of Aerospace Engineering at Delft University of Technology (TU Delft).
        </p>
        <p>
          The purpose of this research study is to collect data regarding how people make decisions 
          and form trust in emergency situations where a robotic agent provides suggestions. 
          The study will take approximately <strong>15–20 minutes</strong> to complete.  
          The data will be used for research in a Master Thesis at the Faculty of Aerospace Engineering of TU Delft.
        </p>
        <p>
          During the study, you will be asked to complete a short questionnaire and then perform 
          a computer-based task in which you decide between different options (e.g., choosing a door), 
          with guidance from a simulated drone.
        </p>
        <p>
          As with any online activity, there is a minimal risk of a data breach. 
          To the best of our ability, your responses in this study will remain 
          <strong>completely anonymous</strong>. No names, email addresses, or IP addresses are collected. 
          The only data recorded are your responses and timing information within the experiment. 
          Data will be stored securely and used exclusively for academic research purposes.
        </p>
        <p>
            Your participation in this study is entirely voluntary and you can withdraw at any time.  
            You are free to omit any questions.  
            If you wish to stop the experiment early, you may click the <strong>Exit</strong> button 
            (shown at the top-right corner of the screen during the task) or press 
            <strong><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>X</kbd></strong> on your keyboard.  
            At that point, you will be given the choice to either keep the data collected so far 
            or to discard it entirely. Once the experiment is completed, the data are anonymous and cannot be linked back to you or removed.
        </p>
        <p>
          If you have any questions about this research, please contact 
          Pedro Silva (<a href="mailto:P.RodriguesCorreiaDaSilva@student.tudelft.nl">P.RodriguesCorreiaDaSilva@student.tudelft.nl</a>). 
          The responsible supervisor for this project is 
          Anahita Jamshidnejad (<a href="mailto:A.Jamshidnejad@tudelft.nl">A.Jamshidnejad@tudelft.nl</a>).
        </p>
        <p>
          Please note that this experiment works best on a <strong>desktop or laptop computer</strong>.  
          While it can run on mobile devices, the interface may be harder to use, and results may be compromised.  
          On desktop, the experiment will automatically switch to <strong>full screen mode</strong>, the recommended mode for completing the study.  
          You can exit full screen at any time by pressing the <strong><kbd>Esc</kbd></strong> key.
        </p>
        <p>
          <strong>By clicking on the button below, you are agreeing to this Opening Statement 
          and giving your consent to participate in this study.</strong>
        </p>
        <div style="text-align:center;">
          <button id="consent-button">I consent — Start experiment</button>
        </div>
      </div>
    </div>

    <!-- Mobile rotate/size gate -->
    <div id="rotate-gate" style="display:none; position:fixed; inset:0; background:#0b0b10; color:#fff; z-index:10002;
      align-items:center; justify-content:center; padding:24px; box-sizing:border-box;">
      <div style="max-width:720px; text-align:center;">
        <h2 style="margin:0 0 12px 0; font-size:24px;">Please rotate your device</h2>
        <p style="opacity:.9; margin:0 0 14px 0;">
          This task works best in <strong>landscape</strong> with enough screen width. Rotate your phone and make sure the address bar is minimized.
        </p>
        <p id="gate-tip" style="opacity:.8; font-size:14px; margin:0 0 18px 0;"></p>
        <button id="gate-check" style="padding:10px 16px; border:none; border-radius:10px; background:#2b6fbf; color:#fff; font-weight:700;">
          I’m ready
        </button>
      </div>
    </div>


    <!-- jsPsych target (hidden until consent) -->
    <div id="jspsych-target" style="display:none;"></div>

    <!-- final screen (hidden until experiment finishes) -->
    <div id="final-screen" style="display:none;">
      <div style="
        min-height:100vh; min-height:100svh; display:flex; align-items:center; justify-content:center;
        padding:20px; box-sizing:border-box; background:#0b0b10; color:#fff; text-align:center;">
        <div style="max-width:760px;">
          <h2 style="margin:0 0 10px 0; font-size:28px; font-weight:700;">
            You may now close this browser tab.
          </h2>
          <p style="margin:8px 0 0 0; opacity:.85">
            Thanks for participating!
          </p>
        </div>
      </div>
    </div>

    <!-- Early exit (keep data) -->
    <div id="final-keep-screen" style="display:none;">
      <div style="min-height:100vh; min-height:100svh; display:flex; align-items:center; justify-content:center;
                  padding:20px; box-sizing:border-box; background:#0b0b10; color:#fff; text-align:center;">
        <div style="max-width:760px;">
          <h2 style="margin:0 0 10px 0; font-size:28px; font-weight:700;">
            You ended the study early (data kept).
          </h2>
          <p style="margin:8px 0 0 0; opacity:.85">
            Thanks for your time — your responses up to this point were saved.
            You may now close this browser tab.
          </p>
        </div>
      </div>
    </div>

    <!-- Early exit (discard data) -->
    <div id="final-discard-screen" style="display:none;">
      <div style="min-height:100vh; min-height:100svh; display:flex; align-items:center; justify-content:center;
                  padding:20px; box-sizing:border-box; background:#0b0b10; color:#fff; text-align:center;">
        <div style="max-width:760px;">
          <h2 style="margin:0 0 10px 0; font-size:28px; font-weight:700;">
            You withdrew from the experiment (data discarded).
          </h2>
          <p style="margin:8px 0 0 0; opacity:.85">
            We’ve removed your responses and ended the study.
            You may now close this browser tab.
          </p>
        </div>
      </div>
    </div>

    <!-- Exit button (hidden until experiment starts) -->
    <button id="exit-btn" style="display:none;">Exit</button>

    <!-- Mobile choice bar (shown only during door trials on mobile) -->
    <div id="mobile-choices" style="display:none; position:fixed; left:0; right:0; bottom:0; z-index:10000;
      padding:12px; box-sizing:border-box; gap:12px;">
      <div style="display:flex; gap:12px;">
        <button id="mob-left"  style="flex:1; padding:14px; font-size:18px; border:none; border-radius:10px;">⬅︎ Left</button>
        <button id="mob-right" style="flex:1; padding:14px; font-size:18px; border:none; border-radius:10px;">Right ➡︎</button>
      </div>
    </div>

    <!-- Exit modal -->
    <div id="exit-modal" class="modal-overlay">
      <div class="modal-card">
        <h3>End experiment?</h3>
        <p>You can resume, or end now. If you choose to discard, we’ll remove the data collected so far.</p>
        <div class="modal-actions">
          <button id="exit-resume" class="btn-secondary">Resume</button>
          <button id="exit-keep" class="btn-primary">Exit & keep data</button>
          <button id="exit-discard" class="btn-danger">Exit & discard data</button>
        </div>
      </div>
    </div>

    <div id="blackout" aria-hidden="true" style="display:none;">
      <div class="blackout-text"></div>
    </div>

    <script>
    // small helper: generate a random participant id
    function randomId(len=8){ return Math.random().toString(36).slice(2, 2+len); }

    // Conservative mobile/tablet detection:
    // - True for phones/tablets (including iPadOS w/ desktop UA)
    // - False for desktop/touch laptops unless viewport is truly small
    const IS_MOBILE = (() => {
      const ua = navigator.userAgent || '';
      const hasTouch = (navigator.maxTouchPoints || 0) > 1;
      const uaPhone  = /Android|iPhone|iPod|Mobile/i.test(ua);
      const uaTablet = /iPad|Tablet/i.test(ua);
      // iPadOS reports "Macintosh" + touch points
      const isIPadOS = /\bMacintosh\b/.test(ua) && hasTouch;
      // Only treat generic touch devices as "mobile" if the physical screen is small
      const smallScreen = Math.min(screen.width, screen.height) <= 820; // CSS px
      return uaPhone || uaTablet || isIPadOS || (hasTouch && smallScreen);
    })();

    // ====== CENTRAL LOGGING CONFIG ======
    const LOG_ENDPOINT = 'https://script.google.com/macros/s/AKfycbwtP8jaBQYYqcGgFE1b9uhxXBlxqMMp0WGccFjbart7Z0LorjZI7FUVKdY2umIV_WjO/exec';

    // Build normalized rows from jsPsych's internal data
    function buildRowsForLogging(allTrials) {
      const ua = navigator.userAgent;
      const nowIso = new Date().toISOString();

      return allTrials.map(d => ({
        participant_id: d.participant_id || '',
        seed: d.seed || '',
        trial_type: d.trial_type || (typeof d.true_location !== 'undefined' ? 'door' : ''),
        victim_skin: d.victim_src || null,

        trial_index: (typeof d.trial_index !== 'undefined') ? d.trial_index : null,
        true_location: (typeof d.true_location !== 'undefined') ? d.true_location : null,
        suggestion: (typeof d.suggestion !== 'undefined') ? d.suggestion : null,

        choice: (typeof d.choice !== 'undefined') ? d.choice : null,
        correct: (typeof d.correct !== 'undefined') ? d.correct : null,
        reaction_time_s: (typeof d.reaction_time_s !== 'undefined') ? d.reaction_time_s : null,

        slider_value: (typeof d.slider_value !== 'undefined') ? d.slider_value : null,
        emergency_choice_index: (d.trial_type === 'survey_button') ? d.choice : null,

        review_condition: (typeof d.review_condition !== 'undefined') ? d.review_condition : null,
        review_expected: (typeof d.review_expected !== 'undefined') ? d.review_expected : null,
        review_ids: (typeof d.review_ids !== 'undefined') ? d.review_ids : null,
        review_tones: (typeof d.review_tones !== 'undefined') ? d.review_tones : null,
        review_avatars: (typeof d.review_avatars !== 'undefined') ? d.review_avatars : null,
        ts: nowIso,
        user_agent: ua
      }));
    }

    // --- Skin loading helpers ---
    const VICTIM_MANIFEST_URL = 'assets/victims/manifest.json';
    const BG_MANIFEST_URL    = 'assets/backgrounds/manifest.json';
    const DOOR_MANIFEST_URL  = 'assets/doors/manifest.json';
    const SMOKE_MANIFEST = {
      left:  'assets/smoke/left/manifest.json',
      right: 'assets/smoke/right/manifest.json'
    };
    const FIRE_MANIFEST = {
      left:  'assets/fire/left/manifest.json',
      right: 'assets/fire/right/manifest.json'
    };

    // Fallbacks if no manifest.json is present
    const DEFAULT_VICTIM_SKINS = [
      'assets/victims/victim1.png',
      'assets/victims/victim1_copy.png',
      'assets/victims/victim2.png',
      'assets/victims/victim2_copy.png',
      'assets/victims/victim3.png',
      'assets/victims/victim3_copy.png',
      'assets/victims/victim4.png',
      'assets/victims/victim4_copy.png',
      'assets/victims/victim5.png',
      'assets/victims/victim5_copy.png',
      'assets/victims/victim6.png',
      'assets/victims/victim6_copy.png'
    ];
    
    const DEFAULT_BACKGROUNDS = [
      'assets/backgrounds/bg1.png',
      'assets/backgrounds/bg2.png',
      'assets/backgrounds/bg3.png'
    ];

    const DEFAULT_DOORS = [
      'assets/doors/door1.png',
      'assets/doors/door2.png',
      'assets/doors/door3.png'
    ];

    async function loadSideList(url, baseDir) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('manifest fetch failed: ' + url);
        const arr = await res.json();
        if (!Array.isArray(arr) || arr.length === 0) throw new Error('empty/invalid manifest: ' + url);
        // Accept bare filenames or full/relative paths; coerce bare names into the baseDir.
        return arr.map(x => {
          if (typeof x !== 'string') return null;
          if (x.startsWith('assets/')) return x;           // already fully pathed
          if (x.includes('/')) return x;                   // some subpath you provided
          return `${baseDir}/${x}`;                        // bare filename -> baseDir + filename
        }).filter(Boolean);
      } catch (e) {
        console.warn('Manifest missing/invalid:', url, e);
        return [];
      }
    }

    function stripExtBase(p) {
      const fname = p.replace(/^.*[\\/]/, '');     // filename.ext
      return fname.replace(/\.[^.]+$/, '');        // filename (no .ext)
    }

    function shuffleInPlace(arr, randFn) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(randFn() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Pick from a list with “no immediate repeat” of the exact same path
    function makeNoRepeatPicker(list, randFn) {
      let last = null;
      let pool = [];
      const refill = () => { pool = shuffleInPlace(list.slice(), randFn); };
      refill();
      return function next() {
        if (!pool.length) refill();
        // try to avoid immediate repeat
        if (pool.length > 1 && pool[pool.length - 1] === last) {
          // swap with a random earlier element
          const k = Math.floor(randFn() * (pool.length - 1));
          [pool[k], pool[pool.length - 1]] = [pool[pool.length - 1], pool[k]];
        }
        last = pool.pop();
        return last;
      };
    }

    // Build a paired picker for left/right with constraints:
    //  - no immediate repeat on each side
    //  - avoid mirrored-pair collision per trial (basename(left) != basename(right))
    function makeMirroredPairPicker(leftList, rightList, randFn) {
      const nextLeftNoRepeat  = makeNoRepeatPicker(leftList, randFn);
      const nextRightNoRepeat = makeNoRepeatPicker(rightList, randFn);

      let lastLeft = null;
      let lastRight = null;

      return function nextPair() {
        // choose LEFT first (no repeat by path)
        let left = nextLeftNoRepeat();

        // choose RIGHT from rightList excluding basename(left)
        const leftBase = stripExtBase(left);
        const candidates = rightList.filter(p => stripExtBase(p) !== leftBase);

        // if exclusion empties the set (degenerate), fall back to full rightList
        const rightPool = candidates.length ? candidates : rightList;

        // “no immediate repeat” for right as well:
        // pick until you avoid repeating lastRight (or give up after a few tries)
        let right = null;
        // a tiny loop to bias away from lastRight
        for (let tries = 0; tries < 3; tries++) {
          const idx = Math.floor(randFn() * rightPool.length);
          right = rightPool[idx];
          if (right !== lastRight) break;
        }
        // still the same? take a different one if possible
        if (right === lastRight && rightPool.length > 1) {
          const alt = rightPool.find(p => p !== lastRight);
          if (alt) right = alt;
        }

        lastLeft = left;
        lastRight = right;
        return { left, right };
      };
    }

    async function loadSmokeAndFirePickers(randFn) {
      const [smLeft, smRight] = await Promise.all([
        loadSideList(SMOKE_MANIFEST.left,  'assets/smoke/left'),
        loadSideList(SMOKE_MANIFEST.right, 'assets/smoke/right'),
      ]);
      const [fiLeft, fiRight] = await Promise.all([
        loadSideList(FIRE_MANIFEST.left,   'assets/fire/left'),
        loadSideList(FIRE_MANIFEST.right,  'assets/fire/right'),
      ]);

      // For preloading:
      const ALL_SMOKE = [...smLeft, ...smRight];
      const ALL_FIRE  = [...fiLeft, ...fiRight];

      return {
        ALL_SMOKE, ALL_FIRE,
        nextSmokePair: makeMirroredPairPicker(smLeft, smRight, randFn),
        nextFirePair:  makeMirroredPairPicker(fiLeft, fiRight, randFn),
      };
    }


    async function loadListFromManifest(url, coercePath) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('manifest fetch failed');
        const arr = await res.json();
        if (!Array.isArray(arr) || arr.length === 0) throw new Error('empty/invalid manifest');
        return arr.map(x => (typeof coercePath === 'function' ? coercePath(x) : x)).filter(Boolean);
      } catch (e) {
        return null; // let caller use fallback
      }
    }

    async function loadBackgrounds() {
      const list = await loadListFromManifest(BG_MANIFEST_URL, x =>
        typeof x === 'string' && x.startsWith('assets/') ? x : `assets/backgrounds/${x}`
      );
      return list || DEFAULT_BACKGROUNDS.slice();
    }

    async function loadDoors() {
      const list = await loadListFromManifest(DOOR_MANIFEST_URL, x =>
        typeof x === 'string' && x.startsWith('assets/') ? x : `assets/doors/${x}`
      );
      return list || DEFAULT_DOORS.slice();
    }

    
    async function loadVictimSkins() {
      try {
        const res = await fetch(VICTIM_MANIFEST_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('manifest fetch failed');
        const arr = await res.json();
        if (!Array.isArray(arr) || arr.length === 0) throw new Error('empty/invalid manifest');

        return arr.map(x => {
          if (typeof x !== 'string') return null;
          return x.startsWith('assets/') ? x : `assets/victims/${x}`;
        }).filter(Boolean);
      } catch (e) {
        console.warn('Victim manifest not found or invalid, using fallback list.', e);
        return DEFAULT_VICTIM_SKINS.slice();
      }
    }

    // ---- Reviews loader ----
    async function loadReviewsJSON() {
      try {
        const res = await fetch('assets/reviews/reviews.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('reviews fetch failed');
        const data = await res.json();
        const buckets = ['very_positive','slightly_positive','mixed','slightly_negative','very_negative'];
        for (const k of buckets) if (!Array.isArray(data[k])) data[k] = [];
        return data;
      } catch (e) {
        console.warn('Reviews JSON missing/invalid; disabling review stage.', e);
        return null;
      }
    }

    // deterministic sampler without replacement
    function sampleK(arr, k, rand = Math.random) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a.slice(0, Math.max(0, Math.min(k, a.length)));
    }

    function pickReviewSet(reviewsData, condition, rand = Math.random) {
      // condition may be null -> random among the five types
      const buckets = ['very_positive','slightly_positive','mixed','slightly_negative','very_negative'];
      const cond = condition && buckets.includes(condition)
        ? condition
        : buckets[Math.floor(rand() * buckets.length)];

      // How many from each tone for the 5-card set:
      // - very_positive:       5 VP
      // - slightly_positive:   3 SP + 2 MIX
      // - mixed:               2 VP + 1 MIX + 2 SN  (balanced around 0)
      // - slightly_negative:   3 SN + 2 MIX
      // - very_negative:       5 VN
      const recipe = {
        very_positive:      { very_positive: 5 },
        slightly_positive:  { slightly_positive: 3, mixed: 2 },
        mixed:              { very_positive: 2, mixed: 1, slightly_negative: 2 },
        slightly_negative:  { slightly_negative: 3, mixed: 2 },
        very_negative:      { very_negative: 5 }
      }[cond];

      const picks = [];
      for (const [tone, k] of Object.entries(recipe)) {
        const pool = reviewsData[tone] || [];
        const take = sampleK(pool, k, rand);
        picks.push(...take.map(r => ({...r, tone })));
      }

      // If some bucket was short, backfill from the same tone; else from mixed
      if (picks.length < 5) {
        const need = 5 - picks.length;
        const fallback = (reviewsData[cond] && reviewsData[cond].length) ? reviewsData[cond] : (reviewsData.mixed || []);
        picks.push(...sampleK(fallback, need, rand).map(r => ({...r, tone: cond})));
      }

      // Shuffle final order for display variety
      return sampleK(picks, 5, rand);
    }


    // ---- Avatar pool (base IDs only; code resolves mood-specific files) ----
    const AVATAR_IDS = ['ff01','ff02','ff03','ff04','ff05','ff06','ff07','ff08','ff09','ff10','ff11','ff12','ff13','ff14' ]; // extend as needed
    const AVATAR_MOODS = ['happy','neutral','sad'];

    // Map review tone → mood
    const MOOD_FOR_TONE = {
      very_positive: 'happy',
      slightly_positive: 'neutral',
      mixed: 'neutral',
      slightly_negative: 'neutral',
      very_negative: 'sad'
    };

    // Build a file path for an avatar base + mood
    function avatarSrc(baseId, mood){
      return `assets/reviews/${baseId}_${mood}.png`;
    }

    // Preload all avatar images (call this once before jsPsych.run)
    function listAllAvatarImages(){
      const out = [];
      for (const id of AVATAR_IDS) {
        for (const m of AVATAR_MOODS) {
          out.push(avatarSrc(id, m));
        }
      }
      return out;
    }

    // Sample k distinct base IDs without replacement.
    // If k > unique pool size, it returns the full pool shuffled and the caller
    // may decide how to handle the shortfall (we handle gracefully below).
    function sampleBaseIdsNoRepeat(k, randFn = Math.random){
      const pool = AVATAR_IDS.slice();
      for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(randFn() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, Math.min(k, pool.length));
    }

    /**
    * Assigns avatars to a review set:
    *  - Uses unique base IDs within the set (no “same rescuer different face”).
    *  - Tone → mood mapping decides which face to load.
    *  - If there are fewer unique base IDs than reviews, we minimally reuse
    *    (never repeating the same baseId twice in a row).
    *
    * Mutates each review object by adding: review.avatar = { baseId, mood, src }
    */
    function assignAvatarsToReviewSet(reviewSet, randFn = Math.random){
      const k = reviewSet.length;
      const uniqueNeeded = Math.min(k, AVATAR_IDS.length);
      const chosenBaseIds = sampleBaseIdsNoRepeat(uniqueNeeded, randFn);

      // If we need more than available unique base IDs, create a spillover list
      // that avoids immediate repeats of the last used baseId.
      let spill = [];
      if (k > chosenBaseIds.length) {
        const extrasNeeded = k - chosenBaseIds.length;
        // Build a shuffled pool for spill, but we’ll pick while avoiding last used.
        const pool = AVATAR_IDS.slice();
        for (let i = pool.length - 1; i > 0; i--) {
          const j = Math.floor(randFn() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        // Take extrasNeeded from pool cycling (ensuring no immediate repeat)
        let last = chosenBaseIds[chosenBaseIds.length - 1] || null;
        while (spill.length < extrasNeeded) {
          const candidate = pool[spill.length % pool.length];
          if (candidate !== last) {
            spill.push(candidate);
            last = candidate;
          } else {
            // pick a different one if possible
            const alt = pool.find(x => x !== last);
            spill.push(alt || candidate);
            last = alt || candidate;
          }
        }
      }

      const allBaseIds = chosenBaseIds.concat(spill);

      // Assign baseId + mood + src to each review
      reviewSet.forEach((r, idx) => {
        const baseId = allBaseIds[idx % allBaseIds.length];
        const mood = MOOD_FOR_TONE[r.tone] || 'neutral';
        r.avatar = { baseId, mood, src: avatarSrc(baseId, mood) };
      });

      // Ensure no accidental duplicate baseId in adjacent cards (if possible)
      for (let i = 1; i < reviewSet.length; i++) {
        if (reviewSet[i].avatar.baseId === reviewSet[i-1].avatar.baseId) {
          // try to swap with a later one that has a different baseId
          for (let j = i + 1; j < reviewSet.length; j++) {
            if (reviewSet[j].avatar.baseId !== reviewSet[i-1].avatar.baseId) {
              const tmp = reviewSet[i].avatar;
              reviewSet[i].avatar = reviewSet[j].avatar;
              reviewSet[j].avatar = tmp;
              break;
            }
          }
        }
      }

      return reviewSet;
    }

  
    function useLightUI(){
      document.body.classList.remove('task-dark');
      try { hideBlackout(); } catch(_) {}
      setDisplayBg('var(--bg)'); // this sets #jspsych-target’s background
    }

    function useDarkUI(){
      document.body.classList.add('task-dark');
      setDisplayBg('#000'); // make sure the display area is also black
    }

    // Smooth cross-fade between blocks (uses your showBlackout/hideBlackout)
    // Usage:
    //   timeline.push(makeFadeTransition('dark', 300));         // legacy (to='dark'|'light')
    //   timeline.push(makeFadeTransition('#111827', 300));      // fade to a custom color
    //   timeline.push(makeFadeTransition({ to: 'light', holdMs: 200, fadeIn: false }));
    //     -> fades OUT, switches to light bg, but STAYS BLACK (no fade-in). Next trial should call hideBlackout().

    function makeFadeTransition(toOrOpts, holdMaybe) {
      // Normalize args: allow (string, number) or ({to, holdMs, fadeIn})
      const opts = (typeof toOrOpts === 'object' && toOrOpts !== null)
        ? toOrOpts
        : { to: toOrOpts, holdMs: holdMaybe };

      const {
        to      = 'light',   // 'dark' | 'light' | any CSS color (e.g. '#0b0b10', 'rgb(10,10,10)')
        holdMs  = 0,         // extra time fully black between out & in
        fadeIn  = true       // false = only fade OUT and leave screen black
      } = opts;

      // Helper: set theme + bg color based on "to"
      function applyThemeAndBg(target) {
        // shorthands
        if (target === 'dark') {
          document.body.classList.add('task-dark');
          setDisplayBg('#000');
          return;
        }
        if (target === 'light') {
          document.body.classList.remove('task-dark');
          setDisplayBg('var(--bg)'); // your questionnaire light background
          return;
        }
        // custom color (CSS)
        const color = String(target || '').trim();
        // naive darkness check
        const looksBlack = /^#000(?:000)?$/i.test(color) || /^black$/i.test(color) || /^rgb\(\s*0\s*,\s*0\s*,\s*0\s*\)$/i.test(color);
        if (looksBlack) document.body.classList.add('task-dark');
        else            document.body.classList.remove('task-dark');
        setDisplayBg(color);
      }

      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: "NO_KEYS",
        stimulus: "",
        on_load: () => {
          window.__LOCK_FX_LAYOUT__ = false;
          // 1) fade to black (no text)
          showBlackout("");

          const fade = (window.CONFIG?.blackout_fade_ms ?? 450);

          // 2) once fully black, switch theme/bg while hidden
          setTimeout(() => {
            applyThemeAndBg(to);
            // 3) fade back in, unless caller wants only fade-out
            if (fadeIn) {
              // optional extra hold while black
              setTimeout(() => {
                hideBlackout();
              }, Math.max(0, Number(holdMs) || 0));
            }
          }, fade + 40);
        },
        trial_duration: () => {
          const fade = (window.CONFIG?.blackout_fade_ms ?? 450);
          const outDur  = fade + 40;                              // fade to black
          const holdDur = Math.max(0, Number(holdMs) || 0);       // fully black hold
          const inDur   = fadeIn ? (fade + 60) : 0;               // fade back in (or skip)
          return outDur + holdDur + inDur;
        }
      };
    }



    // --- Robust logging: sendBeacon first, then fetch keepalive ---
    function logAsync(rows) {
      if (!LOG_ENDPOINT) return Promise.resolve();

      const body = new URLSearchParams();
      body.set('payload', JSON.stringify({ rows }));

      if (navigator.sendBeacon) {
        const blob = new Blob([body.toString()], { type: 'application/x-www-form-urlencoded;charset=UTF-8' });
        const ok = navigator.sendBeacon(LOG_ENDPOINT, blob);
        if (ok) return Promise.resolve();
      }
      return fetch(LOG_ENDPOINT, { method: 'POST', body, keepalive: true });
    }

    // Helper: log a single trial immediately
    function logTrialRow(d) {
      if (window.__DISCARD_DATA__) return;
      try {
        const rows = buildRowsForLogging([d]);
        logAsync(rows).catch(err => console.warn('Logging (incremental) failed:', err));
      } catch (e) {
        console.warn('Failed to build/log trial row:', e);
      }
    }

    // Last-resort flush if the page is being closed
    let _flushed = false;
    window.addEventListener('pagehide', function () {
      if (_flushed) return;
      _flushed = true;
      try {
        const rows = buildRowsForLogging((window.jsPsych?.data?.get?.().values?.()) || []);
        logAsync(rows);
      } catch (_) { /* ignore */ }
    }, { capture: true });

    (function(){
      const consentButton = document.getElementById('consent-button');
      consentButton.addEventListener('click', async () => {
        // Hide consent and reveal jsPsych container
        document.getElementById('consent-screen').style.display = 'none';
        const jsTarget = document.getElementById('jspsych-target');
        jsTarget.style.display = 'block';
        setTimeout(() => { try { window.scrollTo(0, 1); } catch (_) {} }, 0);

        // Try fullscreen wherever available (desktop + iOS 16+ Safari may allow it)
        if (document.documentElement.requestFullscreen) {
          try {
            const el = document.documentElement;
            if (!document.fullscreenElement) {
              if (el.requestFullscreen) {
                await el.requestFullscreen({ navigationUI: 'hide' });
              } else if (el.webkitRequestFullscreen) {
                el.webkitRequestFullscreen();
              } else if (el.msRequestFullscreen) {
                el.msRequestFullscreen();
              }
            }
          } catch (e) {
            console.warn('Fullscreen request was blocked or failed:', e);
          }
        }

        // Mobile: wait until user is in landscape and viewport is wide enough
        if (IS_MOBILE) await waitForMobileGate();

        // Start jsPsych
        await startJsPsych();
      });

    })();

    /* ---------- shared scene helpers (GLOBAL) ---------- */

    // Landscape/size gate (mobile only)
    const MIN_LANDSCAPE_WIDTH = 640;

    function isLandscape() {
      return (window.matchMedia && window.matchMedia('(orientation: landscape)').matches)
        || (window.innerWidth > window.innerHeight);
    }
    function hasEnoughWidth() {
      return window.innerWidth >= MIN_LANDSCAPE_WIDTH;
    }
    function mobileGateSatisfied() {
      return isLandscape() && hasEnoughWidth();
    }

    async function waitForMobileGate() {
      // Do nothing on desktop
      if (!IS_MOBILE) return;

      // Already good? carry on
      if (mobileGateSatisfied()) return;

      const gate = document.getElementById('rotate-gate');
      const tip  = document.getElementById('gate-tip');
      const btn  = document.getElementById('gate-check');

      function updateTip() {
        tip.textContent = `Current view: ${window.innerWidth}×${window.innerHeight}px. Rotate to landscape and ensure ≥ ${MIN_LANDSCAPE_WIDTH}px width.`;
      }

      gate.style.display = 'flex';
      updateTip();

      return new Promise((resolve) => {
        const check = () => {
          updateTip();
          if (mobileGateSatisfied()) {
            window.removeEventListener('resize', check);
            window.removeEventListener('orientationchange', check);
            gate.style.display = 'none';
            resolve();
          }
        };
        window.addEventListener('resize', check, { passive: true });
        window.addEventListener('orientationchange', check, { passive: true });
        btn.addEventListener('click', check, { once: true });
      });
    }



    function decodeImage(img){
      if(!img) return Promise.resolve();
      if('decode' in img) return img.decode().catch(()=>Promise.resolve());
      return new Promise(resolve=>{
        if(img.complete && img.naturalWidth) return resolve();
        img.onload=()=>resolve();
        img.onerror=()=>resolve();
      });
    }

    async function position_scene_overlays(display_element){
      if (window.__LOCK_FX_LAYOUT__) {
        // Only re-apply the current progress transform to keep visuals coherent,
        // but DO NOT re-measure or rewrite left/top.
        try {
          const apply = window.__applyFxProgressPosition;
          if (typeof apply === 'function') apply(window.__fxProgress || 0);
        } catch(_) {}
        return; // <- bail
      }
      const frame = display_element.querySelector('.scene-frame');
      if(!frame) return;

      const bg = frame.querySelector('.background');
      await decodeImage(bg);

      // Fallback if decode didn’t populate size yet
      if (!(bg.naturalWidth > 0 && bg.naturalHeight > 0)) {
        bg.addEventListener('load', () => position_scene_overlays(display_element), { once: true });
        console.warn('[FX] background not ready; retrying on load');
        return;
      } 


      const origBgW = bg.naturalWidth || bg.width;
      const origBgH = bg.naturalHeight || bg.height;

      // Use the visible container (safe viewport inside your fixed #jspsych-target)
      const viewportW = display_element.clientWidth || window.innerWidth;
      const viewportH = display_element.clientHeight || window.innerHeight;

      // Scale-to-contain: fit the whole background inside the viewport (no cropping, no squish)
      const scale = Math.min(viewportW / origBgW, viewportH / origBgH);

      const dispBgW = Math.round(origBgW * scale);
      const dispBgH = Math.round(origBgH * scale);

      // ---------- Foreground FX (smoke/fire, left & right) ----------
      // Match background height exactly; compute width from natural size to preserve aspect
      const smokeL = frame.querySelector('.smoke-left');
      const smokeR = frame.querySelector('.smoke-right');
      const fireL  = frame.querySelector('.fire-left');
      const fireR  = frame.querySelector('.fire-right');

      // Ensure images are decoded so natural sizes are available
      await Promise.all([smokeL, smokeR, fireL, fireR].map(decodeImage));

      function scaleToBgHeight(imgEl) {
        if (!imgEl) return { w: 0, h: 0 };
        const natW = imgEl.naturalWidth  || 0;
        const natH = imgEl.naturalHeight || 1; // avoid /0
        const scaleH = dispBgH / natH;
        return { w: Math.round(natW * scaleH), h: dispBgH };
      }

      const sL = scaleToBgHeight(smokeL);
      const sR = scaleToBgHeight(smokeR);
      const fL = scaleToBgHeight(fireL);
      const fR = scaleToBgHeight(fireR);

      // Size the elements (height = bg height, width = scaled to preserve aspect)
      if (smokeL) { smokeL.style.height = sL.h + 'px'; smokeL.style.width = sL.w + 'px'; }
      if (smokeR) { smokeR.style.height = sR.h + 'px'; smokeR.style.width = sR.w + 'px'; }
      if (fireL)  { fireL.style.height  = fL.h + 'px'; fireL.style.width  = fL.w + 'px'; }
      if (fireR)  { fireR.style.height  = fR.h + 'px'; fireR.style.width  = fR.w + 'px'; }

      // Base alignment (time 0)
      //  - LEFT images: right edge flush with frame right → left = dispBgW - scaledW
      //  - RIGHT images: left edge flush with frame left → left = 0
      const baseLeft_smokeL = dispBgW - sL.w;
      const baseLeft_smokeR = 0;
      const baseLeft_fireL  = dispBgW - fL.w;
      const baseLeft_fireR  = 0;

      const smokeYOffset = (window.CONFIG?.smoke_y_offset_px ?? 0);
      if (smokeL) { smokeL.style.left = baseLeft_smokeL + 'px'; smokeL.style.top = smokeYOffset + 'px'; smokeL.style.transform = 'translate(0px, 0px)';}
      if (smokeR) { smokeR.style.left = baseLeft_smokeR + 'px'; smokeR.style.top = smokeYOffset + 'px'; smokeR.style.transform = 'translate(0px, 0px)';}
      if (fireL)  { fireL.style.left  = baseLeft_fireL  + 'px'; fireL.style.top  = '0px'; fireL.style.transform = 'translate(0px, 0px)';}
      if (fireR)  { fireR.style.left  = baseLeft_fireR  + 'px'; fireR.style.top  = '0px'; fireR.style.transform = 'translate(0px, 0px)';}

      // Fixed smoke opacity (no time fade)
      const sOpacity = (window.CONFIG?.smoke_opacity ?? 0.32);
      [smokeL, smokeR].forEach(el => { if (el) el.style.setProperty('--smoke-opacity', String(sOpacity)); });

      // Progress-driven motion (inward + smoke rise)
      window.__fxProgress = window.__fxProgress ?? 0;
      applyFxProgressPosition(window.__fxProgress);

      function applyFxProgressPosition(progress){
        const fireSlide  = (window.CONFIG?.fire_inward_px ?? 60);
        const smokeSlide = (window.CONFIG?.smoke_inward_px ?? 30);
        const smokeRise  = (window.CONFIG?.smoke_rise_px ?? 24);

        const fireBase  = (window.CONFIG?.fire_base_inset_px  ?? 0);
        const smokeBase = (window.CONFIG?.smoke_base_inset_px ?? 0);

        // Compute transform deltas (do NOT touch left/top anymore)
        const dxFireL  =  fireBase + fireSlide  * progress;
        const dxFireR  = -fireBase - fireSlide  * progress;
        const dxSmokeL =  smokeBase + smokeSlide * progress;
        const dxSmokeR = -smokeBase - smokeSlide * progress;
        const dySmoke  = -smokeRise * progress;

        if (fireL)  fireL.style.transform  = `translate(${dxFireL}px, 0px)`;
        if (fireR)  fireR.style.transform  = `translate(${dxFireR}px, 0px)`;
        if (smokeL) smokeL.style.transform = `translate(${dxSmokeL}px, ${dySmoke}px)`;
        if (smokeR) smokeR.style.transform = `translate(${dxSmokeR}px, ${dySmoke}px)`;
      }



      // expose the current instance to the rest of the trial
      window.__applyFxProgressPosition = applyFxProgressPosition;

      // Size the frame to match the displayed background
      frame.style.width  = dispBgW + 'px';
      frame.style.height = dispBgH + 'px';

      // Size the background
      bg.style.width  = dispBgW + 'px';
      bg.style.height = dispBgH + 'px';

      // ---------- Doors & revealed ----------
      const overlays = frame.querySelectorAll('.overlay');
      overlays.forEach(el=>{
        const origX  = parseFloat(el.getAttribute('data-orig-x'))||0;
        const origY  = parseFloat(el.getAttribute('data-orig-y'))||0;
        const doorImg= el.querySelector('.door-image');

        const doorW = doorImg.naturalWidth  || doorImg.width  || 360;
        const doorH = doorImg.naturalHeight || doorImg.height || Math.round(doorW*1.3);

        // displayed door size after scaling
        const dispW = Math.round(doorW * scale);
        const dispH = Math.round(doorH * scale);

        const dispLeft = Math.round(origX * scale);
        const dispTop  = Math.round(origY * scale);

        // position the overlay container
        el.style.left   = dispLeft + 'px';
        el.style.top    = dispTop  + 'px';
        el.style.width  = dispW    + 'px';
        el.style.height = dispH    + 'px';

        // revealed image (victim / empty)
        const revealed = el.classList.contains('left-door')
          ? frame.querySelector('.left-revealed')
          : frame.querySelector('.right-revealed');

        if (revealed) {
          const naturalW = revealed.naturalWidth  || 0;
          const naturalH = revealed.naturalHeight || 0;

          let revW = naturalW ? Math.round(naturalW * scale) : Math.round(dispW * 0.9);
          let revH = naturalH ? Math.round(naturalH * scale) : Math.round(dispH * 0.9);

          const fitFactor = 1;
          revW = Math.round(revW * fitFactor);
          revH = Math.round(revH * fitFactor);

          const revLeftInside = Math.round((dispW - revW) / 2);

          const fractionUpFromBottom = 0.45;
          const targetY_fromTop = dispH - (dispH * fractionUpFromBottom);
          const revTopInside = Math.round(targetY_fromTop - (revH / 2));

          revealed.style.width  = revW + 'px';
          revealed.style.height = revH + 'px';
          revealed.style.left   = (dispLeft + revLeftInside) + 'px';
          revealed.style.top    = (dispTop  + revTopInside)  + 'px';
        }
      });

      // ---------- Drone centered between doors, vertically centered ----------
      const leftEl  = frame.querySelector('.left-door');
      const rightEl = frame.querySelector('.right-door');
      const drone   = frame.querySelector('.overlay-drone');
      if(drone && leftEl && rightEl){
        const leftW = parseFloat(leftEl.style.width)||0;
        const leftL = parseFloat(leftEl.style.left)||0;
        const rightW= parseFloat(rightEl.style.width)||0;
        const rightL= parseFloat(rightEl.style.left)||0;
        const leftCenter  = leftL  + leftW/2;
        const rightCenter = rightL + rightW/2;

        const bodyImg = drone.querySelector('.drone-body');
        await decodeImage(bodyImg);  // ensure dimensions are ready

        const natW = bodyImg?.naturalWidth  || 160;
        const natH = bodyImg?.naturalHeight || 100;

        const droneDispW = Math.round(natW * scale);
        const droneDispH = Math.round(natH * scale);

        drone.style.width  = droneDispW + 'px';
        drone.style.height = droneDispH + 'px';

        const midX = (leftCenter + rightCenter) / 2;
        drone.style.left = Math.round(midX - droneDispW / 2) + 'px';
        drone.style.top  = Math.round((dispBgH - droneDispH) / 2) + 'px';
      }
    }


    function attach_positioning(display_element){
      position_scene_overlays(display_element);
      let to=null;
      const handler=()=>{
        if (window.__LOCK_FX_LAYOUT__) return;  // ignore resizes after lock
        if(to) clearTimeout(to);
        to=setTimeout(()=>position_scene_overlays(display_element),80);
      };
      window.addEventListener('resize', handler);
      return ()=>window.removeEventListener('resize', handler);
    }



    function setDisplayBg(color){
      const el = (typeof jsPsych !== 'undefined' && jsPsych.getDisplayElement) ? jsPsych.getDisplayElement() : null;
      if (el) { el.style.background = color; el.style.backgroundColor = color; }
    }

    function lockScroll(){
      document.documentElement.style.overflow = 'hidden';
      document.body.style.overflow = 'hidden';
    }
    function unlockScroll(){
      document.documentElement.style.overflow = '';
      document.body.style.overflow = '';
    }

    function isExitOpen(){
      const m = document.getElementById('exit-modal');
      return !!m && getComputedStyle(m).display === 'flex';
    }

    function ensureBlackoutLayer(){

      let el = document.getElementById('blackout');
      if (!el){
        el = document.createElement('div');
        el.id = 'blackout';
        el.innerHTML = '<div class="blackout-text"></div>';
        document.body.appendChild(el);
      }
      return el;
    }

    function hasEnded() {
      return !!window.__MANUAL_END__ || !!window.__END_REASON__ ||
            document.getElementById('final-screen')?.style.display === 'block' ||
            document.getElementById('final-keep-screen')?.style.display === 'block' ||
            document.getElementById('final-discard-screen')?.style.display === 'block';
    }


    function showBlackout(text) {
      if (hasEnded()) return;

      const el = ensureBlackoutLayer();
      const t  = el.querySelector('.blackout-text');
      if (t) { t.textContent = ''; t.style.opacity = ''; } // reset opacity
      if (!el || !t) return;

      // If a previous reveal is pending, cancel it
      if (el._revealTO) {
        clearTimeout(el._revealTO);
        el._revealTO = null;
      }

      // 1) Prepare: hide text during the screen fade to black
      t.textContent = '';
      t.style.opacity = '0';

      el.style.display = 'block';

      // Keep your exit-modal pass-through behavior
      el.style.pointerEvents = isExitOpen() ? 'none' : 'auto';

      // Trigger the screen fade to black
      requestAnimationFrame(() => el.classList.add('show'));

      // 2) After the blackout finishes, reveal the text (if provided) with its own fade-in
      const fadeMs = (window.CONFIG?.blackout_fade_ms ?? 450);
      el._revealTO = setTimeout(() => {
        el._revealTO = null;
        if (!text) return;                 // no text requested → stay pure black
        t.textContent = text;
        // Smooth text fade-in
        t.animate([{ opacity: 0 }, { opacity: 1 }], {
          duration: 300,
          easing: 'ease-out',
          fill: 'forwards'
        });
      }, fadeMs);
    }

    function hideBlackout(){
      const el = ensureBlackoutLayer();
      if (!el.classList.contains('show')) return; // already hidden
      el.classList.remove('show');
      const fade = window.CONFIG?.blackout_fade_ms ?? 260;
      setTimeout(()=>{
        el.style.display = 'none';
        const t = el.querySelector('.blackout-text');
        if (t) t.textContent = '';
      }, fade);
    }

    // Optional: endpoint action to delete a participant's rows server-side.
    async function requestDeleteByParticipant(participantId) {
      if (!participantId || !LOG_ENDPOINT) return;
      const body = new URLSearchParams();
      body.set('action', 'delete_by_participant');
      body.set('participant_id', participantId);

      if (navigator.sendBeacon) {
        const blob = new Blob([body.toString()], { type: 'application/x-www-form-urlencoded;charset=UTF-8' });
        navigator.sendBeacon(LOG_ENDPOINT, blob);
        return;
      }
      try { await fetch(LOG_ENDPOINT, { method: 'POST', body, keepalive: true }); } catch(_) {}
    }

    // Simple modal controls
    function showExitModal(jsPsych){
      try { jsPsych.pauseExperiment(); } catch(_) {}
      document.getElementById('exit-modal').style.display = 'flex';
    }
    function hideExitModal(jsPsych){
      document.getElementById('exit-modal').style.display = 'none';
      try { jsPsych.resumeExperiment(); } catch(_) {}
    }

    function showEndScreenKeep() {
      document.getElementById('final-screen')?.style.setProperty('display','none');
      document.getElementById('final-keep-screen')?.style.setProperty('display','block');
      document.getElementById('jspsych-target')?.style.setProperty('display','none');
      document.getElementById('exit-btn')?.style.setProperty('display','none');
    }
    function showEndScreenDiscard() {
      document.getElementById('final-screen')?.style.setProperty('display','none');
      document.getElementById('final-discard-screen')?.style.setProperty('display','block');
      document.getElementById('jspsych-target')?.style.setProperty('display','none');
      document.getElementById('exit-btn')?.style.setProperty('display','none');
    }

    /* ---------- main ---------- */

    async function startJsPsych(){
      if (typeof initJsPsych !== 'function') throw new Error('initJsPsych not found');

      const jsPsych = initJsPsych({
        display_element: document.getElementById('jspsych-target'),
        on_finish: function(){
          if (window.__MANUAL_END__) return;

          try { if (document.fullscreenElement && document.exitFullscreen) { document.exitFullscreen().catch(()=>{}); } } catch(_){}
          document.documentElement.style.overflow = '';
          document.body.style.overflow = '';

          const target = document.getElementById('jspsych-target');
          const final  = document.getElementById('final-screen');
          const keep   = document.getElementById('final-keep-screen');
          const disc   = document.getElementById('final-discard-screen');

          if (target) target.style.display = 'none';
          document.getElementById('exit-btn')?.style.setProperty('display','none');
          document.body.classList.remove('task-dark');

          if (window.__END_REASON__ === 'discard') {
            disc?.style.setProperty('display','block');
          } else if (window.__END_REASON__ === 'keep') {
            keep?.style.setProperty('display','block');
          } else {
            final?.style.setProperty('display','block');
          }

          if (!window.__DISCARD_DATA__) {
            const rows = buildRowsForLogging(jsPsych.data.get().values());
            logAsync(rows).catch(err => console.warn('Logging failed:', err));
          }
        }
      });

      const timeline = [];
      const pid = randomId(8);
      window.PID = pid;

      // ---- CONFIG (URL-overridable) + RNG SEED ----
      const CONFIG = {
        N: 20,
        drone_success_rate: 0.75,
        sequence: null,
        seed: null,
        drone_buffer_ms: 2000,       // sweep time
        drone_anim_ms: 1050,        // drone travel time
        drone_prebuffer_ms: 1000,     // cone appear time
        // Entry
        drone_entry_cruise_px_per_s: 460,  // constant cruise during entry
        drone_entry_decel_frac: 0.16,      // last 16% distance is ease-out
        // Hop
        drone_hop_speed_px_per_s: 320,
        drone_hop_duration_scale: 1.10,  // multiplier on the computed duration
        drone_hop_min_ms: 900,
        // Exit
        drone_exit_accel_frac: 0.16,
        drone_exit_accel_speed_px_per_s: 360,
        drone_exit_cruise_px_per_s: 520,
        drone_exit_edge_offset_px: 10,
        // --- cone apex tuning ---
        cone_apex_lift_px: 6,     // minimum upward lift (px)
        cone_apex_lift_ratio: 0.09, // extra lift proportional to drone height
        cone_apex_rel_y: 0.22,    // where inside the drone box the emitter sits (0 = top, 1 = bottom)
        cone_apex_dx: -3,       // optional: nudge apex horizontally (+right / -left) if needed
        cone_dwell_ms: 220,   // pause length at each door (per stop)
        cone_persp_max_squash: 0.35,  // 0..1  (how much shorter at extreme angle)
        cone_persp_max_skew_deg: 6,   // degrees of skewX at extreme angle
        cone_persp_spread_x: 0.10,    // extra scaleX at extreme angle (subtle widening)
        cone_persp_kickin: 0.70, // 0..1 portion of the rotation completed before perspective ramps
        decision_timeout_ms: 4000,    // e.g., 4000 (null disables timer)
        timer_warn_ms: 2000,          // style turns yellow under this
        timer_critical_ms: 1000,      // style turns red under this
        timer_action: 'auto_follow',  // 'auto_follow' | 'none'
        env_warmth: 'warm',      // 'cool' | 'warm' | 'hot' (default applied to all trials)
        env_show_pct: true,      // show small % number at the right
        env_pulse_threshold: 1.0, // start pulsing when integrity < threshold
        blackout_text: 'Relocating to next search area...',            // e.g., 'Relocating…' (empty = no text)
        blackout_hold_ms: 1500,        // extra time the screen stays fully black before next trial
        blackout_fade_ms: 450,         // keep in sync with CSS #blackout transition
        drone_exit_delay_ms: 350,
        panel_delay_after_open_ms: 300, // delay after door fully opens, before showing panel
        panel_hold_ms: 1100,            // how long to keep the panel on-screen
        // --- Foreground FX (fire/smoke) ---
        fire_inward_px: 110,           // total inward slide per side (CSS px at displayed scale)
        smoke_inward_px: 100,          // smaller inward slide for smoke
        smoke_rise_px: 100,            // smoke rises this many px during the trial
        smoke_opacity: 0.95,          // fixed (time-invariant) smoke opacity
        fire_base_inset_px: 40,   // tune until you see flame on both edges
        smoke_base_inset_px: 40,  // tune until smoke is visible
        smoke_y_offset_px: 120,   // how many pixels below the frame top the smoke starts
        // Reputation / reviews
        review_condition: null,           // 'very_positive' | 'slightly_positive' | 'mixed' | 'slightly_negative' | 'very_negative' | null=random
        review_set_size: 5,               // always 5
        review_reveal_stagger_ms: 300,    // delay between card reveals
        review_expected_map: {            // mapping from set → expected initial reputation (for your model; unitless -1..+1)
          very_positive: +1.0,
          slightly_positive: +0.5,
          mixed: 0.0,
          slightly_negative: -0.5,
          very_negative: -1.0
        },
        trust_probe_every_min: 5,   // show after every 5–6 trials (jitter)
        trust_probe_every_max: 6,   // set both to 5 for fixed every-5
        training: {
          enabled: true,          // ?train=0 disables
          n: 1,               // how many short demo scenes to auto-play
          p: 0.80,                // suggestion correctness shown in demos (visual only)
          dwell_ms: 1200,         // hover at the suggested door before blackout
          show_decision_box: false, // keep the “Follow / Choose other door” HUD hidden in demos
          show_outcome: false,      // never open a door or show success/failure in demos
          blackout_text: 'The main task will now begin.'
        },
      };

      // --- Discrete risk model (levels you can log/use as input to your trust model) ---
      CONFIG.risk_levels = {
        // You can tune these. Each level defines:
        // - warmth: scene tint ("cool" | "warm" | "hot")
        // - fire_inward_px, smoke_inward_px, smoke_rise_px: visual encroachment
        // - timeout_scale: scales decision window (same curve; just shorter/longer)
        // - shake_amp_px, shake_period_ms: optional camera shake params
        low:    { warmth:'cool', fire_inward_px:  60, smoke_inward_px:  50, smoke_rise_px:  50, timeout_scale: 1.00, shake_amp_px: 0, shake_period_ms: 900 , risk_value: 0.2},
        medium: { warmth:'warm', fire_inward_px:  90, smoke_inward_px:  80, smoke_rise_px:  80, timeout_scale: 0.85, shake_amp_px: 1, shake_period_ms: 850 , risk_value: 0.5},
        high:   { warmth:'hot',  fire_inward_px: 110, smoke_inward_px: 100, smoke_rise_px: 100, timeout_scale: 0.70, shake_amp_px: 3, shake_period_ms: 800 , risk_value: 0.8},
        extreme:{ warmth:'hot',  fire_inward_px: 130, smoke_inward_px: 120, smoke_rise_px: 120, timeout_scale: 0.55, shake_amp_px: 5, shake_period_ms: 760 , risk_value: 1.0}
      };

      // Minimum time so the drone can: prebuffer + scan + hop, *plus* a small decision window.
      function computeMinDecisionTimeMs(cfg) {
        const preMs = (cfg.drone_prebuffer_ms ?? 1000);
        const scan  = (cfg.drone_buffer_ms ?? 1200);
        const hop   = (cfg.drone_anim_ms ?? 1100);
        const margin = 900; // gives at least ~0.9s to perceive & act
        return preMs + scan + hop + margin;
      }

      // Map a risk key to per-trial overrides, *clamping* timeout so scanning & hop still fit.
      function makeRiskOverrides(riskKey, baseTimeoutMs, cfg) {
        const R = cfg.risk_levels[riskKey] || cfg.risk_levels.medium;
        const minAllowed = computeMinDecisionTimeMs(cfg);
        const scaledTimeout = Math.round(baseTimeoutMs * (R.timeout_scale ?? 1));
        const adjustedTimeout = Math.max(minAllowed, scaledTimeout);

        return {
          risk_key: riskKey,
          warmth: R.warmth,
          fire_inward_px: R.fire_inward_px,
          smoke_inward_px: R.smoke_inward_px,
          smoke_rise_px: R.smoke_rise_px,
          decision_timeout_ms: adjustedTimeout,
          shake_amp_px: R.shake_amp_px,
          shake_period_ms: R.shake_period_ms,
          risk_value: R.risk_value
        };
      }

      window.CONFIG = CONFIG;

      // Pick condition (set preferDeterministic=true to balance cells by PID)
      if (typeof pickCondition === 'function' && typeof applyConditionToConfig === 'function') {
        const CONDITION = pickCondition({ pid, preferDeterministic: true });
        applyConditionToConfig(CONDITION);   // this mutates window.CONFIG
        CONFIG.condition_id = CONDITION?.id || null;
      } else {
        console.warn('conditions.js not loaded; proceeding with default CONFIG.');
        CONFIG.condition_id = null;
      }

      // Include in jsPsych global properties so it’s logged on every row
      jsPsych.data.addProperties({
        condition_id: CONFIG.condition_id
      });


      document.getElementById('exit-btn').style.display = 'block';



      function parseSequenceParam() {
        const p = new URLSearchParams(location.search).get('seq');
        if (!p) return null;
        const map = { L: 'left', R: 'right' };
        return p.split(',').map(pairStr => {
          const pair = pairStr.trim().toUpperCase();
          if (pair.length < 2) return null;
          const v = map[pair[0]];
          const s = map[pair[1]];
          if (!v || !s) return null;
          return { true_location: v, suggestion: s };
        }).filter(Boolean);
      }

      function readConfigFromURL() {
        const sp = new URLSearchParams(location.search);
        const N = parseInt(sp.get('N'), 10);
        const p = parseFloat(sp.get('p'));
        const seed = parseInt(sp.get('seed'), 10);
        const seq = parseSequenceParam();
        const buf = parseInt(sp.get('buffer'), 10);      // e.g., ?buffer=900
        const anim = parseInt(sp.get('anim'), 10);       // e.g., ?anim=1200
        const warmth = sp.get('warmth'); // 'cool' | 'warm' | 'hot'
        const pulse  = parseFloat(sp.get('env_pulse'));
        const showPct = sp.get('env_show_pct');
        const timeout = parseInt(sp.get('timeout') || sp.get('timer'), 10);
        const rev = sp.get('rev');
        const trainFlag = sp.get('train');               // '0' disables
        const trainDemos = parseInt(sp.get('trainDemos'), 10);
        const trainP = parseFloat(sp.get('trainP'));
        const trainDwell = parseInt(sp.get('trainDwell'), 10);
        if (!isNaN(N) && N > 0) CONFIG.N = N;
        if (!isNaN(p) && p >= 0 && p <= 1) CONFIG.drone_success_rate = p;
        if (!isNaN(seed)) CONFIG.seed = seed;
        if (seq && seq.length > 0) CONFIG.sequence = seq;
        if (!isNaN(buf) && buf >= 0) CONFIG.drone_buffer_ms = buf;
        if (!isNaN(anim) && anim >= 0) CONFIG.drone_anim_ms = anim;
        if (warmth === 'cool' || warmth === 'warm' || warmth === 'hot') CONFIG.env_warmth = warmth;
        if (!isNaN(pulse) && pulse >= 0 && pulse <= 1) CONFIG.env_pulse_threshold = pulse;
        if (showPct === '0' || showPct === 'false') CONFIG.env_show_pct = false;
        if (showPct === '1' || showPct === 'true')  CONFIG.env_show_pct = true;
        if (!isNaN(timeout) && timeout >= 0) CONFIG.decision_timeout_ms = timeout;
        if (['very_positive','slightly_positive','mixed','slightly_negative','very_negative'].includes(rev)) {
          CONFIG.review_condition = rev;
        }
        if (trainFlag === '0' || trainFlag === 'false') CONFIG.training.enabled = false;
        if (!isNaN(trainDemos) && trainDemos >= 0) CONFIG.training.demos = trainDemos;
        if (!isNaN(trainP) && trainP >= 0 && trainP <= 1) CONFIG.training.p = trainP;
        if (!isNaN(trainDwell) && trainDwell >= 200) CONFIG.training.dwell_ms = trainDwell;
      }
      readConfigFromURL();

      // Read named set id from URL, e.g. ?set=SetA
      (function readSetFromURL(){
        const sp = new URLSearchParams(location.search);
        const setId = sp.get('set');   // "SetA" | "SetB" | ... | null
        if (setId) window.CONFIG.set_id = setId;
      })();


      function mulberry32(a){
        a |= 0;
        return function(){
          a = (a + 0x6D2B79F5) | 0;
          let t = Math.imul(a ^ (a >>> 15), 1 | a);
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      let RAND = Math.random;
      if (CONFIG.seed !== null) RAND = mulberry32(CONFIG.seed);

      // --- Single-link mode toggles (no URL required) ---
      window.CONFIG = window.CONFIG || {};
      CONFIG.single_link_mode = true;          // one link for all participants
      CONFIG.allow_url_override = true;        // keep debugging via ?set=... if you want
      CONFIG.local_key = 'hri_set_id_v1';

      // Optional: if you collect a code in your consent form
      CONFIG.participant_code_input_id = 'participant-code'; // add an <input id="participant-code"> if you like

      // Simple string hash → 0..(m-1)
      function hashToBucket(str, m) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h % m;
      }

      function getParticipantCode() {
        const el = document.getElementById(CONFIG.participant_code_input_id);
        return el && el.value && el.value.trim() ? el.value.trim() : null;
      }


      jsPsych.data.addProperties({
        participant_id: pid,
        seed: CONFIG.seed,
        config_N: CONFIG.N,
        config_drone_success_rate: CONFIG.drone_success_rate,
        config_sequence_len: CONFIG.sequence ? CONFIG.sequence.length : 0
      });

      // ---- Victim skins + no-repeat picker ----
      const VICTIMS = await loadVictimSkins();
      function shuffleInPlace(arr, randFn) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(randFn() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      function makeSkinPicker(victimList, randFn) {
        let pool = [];
        const refill = () => { pool = shuffleInPlace(victimList.slice(), randFn); };
        refill();
        return function nextSkin() {
          if (pool.length === 0) refill();
          return pool.pop();
        };
      }
      const pickVictimSkin = makeSkinPicker(VICTIMS, RAND);

      // ---- Background / Door / FX lists + no-repeat pickers ----
      const BACKGROUNDS      = await loadBackgrounds();
      const DOOR_SKINS       = await loadDoors();

      const pickBackground   = makeSkinPicker(BACKGROUNDS, RAND);
      const pickDoorSkin     = makeSkinPicker(DOOR_SKINS, RAND);
      

      // ---- Smoke/Fire pickers (left/right, mirrored-pair-safe) ----
      const { ALL_SMOKE, ALL_FIRE, nextSmokePair, nextFirePair } = await loadSmokeAndFirePickers(RAND);

      // Preload
      jsPsych.pluginAPI.preloadImages([
        ...BACKGROUNDS,
        'assets/drone.png',
        ...DOOR_SKINS,
        'assets/empty.png',
        'assets/drone_description.png',
        ...ALL_SMOKE,
        ...ALL_FIRE,
        ...VICTIMS,
        ...listAllAvatarImages()
      ]);


      // ---- Fullscreen helper trial if needed (desktop only) ----
      const needFullscreenTrial =
        !IS_MOBILE &&
        !document.fullscreenElement &&
        !(document.webkitFullscreenElement) &&
        !(document.msFullscreenElement);

      if (needFullscreenTrial) {
        const enter_fullscreen = {
          type: jsPsychFullscreen,
          fullscreen_mode: true,
          message: '<p>For the best experience, we will switch to full screen.</p>',
          button_label: 'Enter full screen'
        };
        timeline.push(enter_fullscreen);
      }

      // ---- New intro screens: Overview (rescuer) + Robot Description ----
      const overview_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
          <div style="
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: left;
            max-width: 900px;
            margin: 0 auto;
          ">
            <div>
              <h2 style="margin:0 0 10px 0;">Experiment Overview</h2>
              <p>
                In this experiment, you will take on the role of a <strong>rescuer</strong> participating in a simulated
                <strong>urban search and rescue (SAR)</strong> mission. Your objective is to locate and save victims trapped
                inside a damaged building by making a series of <em>door-by-door</em> decisions about which areas to
                search next.
              </p>
              <p>
                To support you in this mission, you will receive advice from an <strong>autonomous aerial robot (drone)</strong>
                that assists human firefighters in similar real-world operations. The drone will analyze sensor data and provide
                recommendations about which door it believes is the safest or most promising to open next.
              </p>
              <p>
                As the rescuer, you must decide in each situation whether to <strong>follow the drone’s advice</strong> or
                <strong>rely on your own judgment</strong>. Keep in mind that the drone is <strong>not infallible</strong>—it may
                sometimes make incorrect or misleading recommendations due to sensor noise, smoke, or complex environmental conditions.
              </p>
              <p>
                Before beginning the mission, you will be asked several questions about your <strong>initial perception of this
                specific robot</strong>. These questions focus on your <strong>level of trust</strong> in the robot’s abilities and
                behavior as your teammate in the rescue task.
              </p>
              <p>Please read the following <strong>robot description</strong> carefully before answering the upcoming questionnaire.</p>
            </div>
            <button id="next-button" style="
              margin-top: 30px;
              padding: 12px 28px;
              font-size: 18px;
              border: none;
              border-radius: 8px;
              background-color: #2a6ebb;
              color: white;
              cursor: pointer;
              box-shadow: 0 4px 14px rgba(0,0,0,0.1);
            ">Next</button>
          </div>
        `,
        choices: "NO_KEYS",
        on_load: function() {
          const btn = document.getElementById('next-button');
          btn.addEventListener('click', () => jsPsych.finishTrial());
        },
        data: { trial_type: 'overview_rescuer' },
        on_finish: d => { logTrialRow(d); }
      };


      // ---- Robot Description: vertical layout (image above, text below) ----
      // ---- Robot Description: vertical layout without header ----
      const robot_description_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
          <div style="
            display:flex;
            flex-direction:column;
            justify-content:center;
            align-items:center;
            min-height:100vh;
            text-align:left;
            padding:20px;
            box-sizing:border-box;
          ">

            <!-- IMAGE (top) -->
            <img
              src="assets/drone_description.png"
              alt="Rescue drone"
              style="
                width:100%;
                max-width:700px;
                border:none;
                box-shadow:none;
                margin:0 auto 25px auto;
                display:block;
              "
            />

            <!-- TEXT (below image) -->
            <div style="width:100%; max-width:900px; margin:0 auto;">
              <p>
                The robot you will interact with in this experiment is an <em>autonomous aerial search-and-rescue drone</em>
                designed to assist human rescuers during indoor emergency operations. It helps identify victims, assess
                hazardous environments, and recommend which areas should be entered next to maximize safety and rescue efficiency.
              </p>
              <p>
                The drone operates <strong>semi-autonomously</strong>: it uses onboard cameras and thermal sensors to detect signs of life,
                analyzes the data, and communicates its recommendations to you—the human rescuer—through an on-screen interface.
                Although it is equipped with advanced perception and navigation algorithms, it can still make <strong>errors</strong>,
                particularly in situations involving poor visibility, debris, or heat interference.
              </p>
              <p>
                During the mission, you will act as the <strong>decision-maker</strong> responsible for evaluating the drone’s advice
                and choosing whether to follow it or not. Your performance will depend on your ability to balance your own judgment
                with the information provided by the drone. The overall goal is to <strong>find victims efficiently and safely</strong>,
                while minimizing the risks associated with entering dangerous areas.
              </p>

              <!-- CONTINUE BUTTON -->
              <div style="display:flex; justify-content:center; margin-top:24px;">
                <button id="continue-button" style="
                  padding: 12px 28px;
                  font-size: 18px;
                  border: none;
                  border-radius: 8px;
                  background-color: #2a6ebb;
                  color: white;
                  cursor: pointer;
                  box-shadow: 0 4px 14px rgba(0,0,0,0.1);
                ">
                  Continue
                </button>
              </div>
            </div>
          </div>
        `,
        choices: "NO_KEYS",
        on_load: function () {
          document
            .getElementById('continue-button')
            .addEventListener('click', () => jsPsych.finishTrial());
        },
        data: { trial_type: 'robot_description' },
        on_finish: d => { logTrialRow(d); }
      };

      // ---- Schaefer 40-item HRI Trust questionnaire (pre-task) ----

      // Full item list (Schaefer 2013, Table 35). Reverse-coded items are flagged.
      // ---- Schaefer 40-item HRI Trust questionnaire (single-item, paged) ----

      // ---- Schaefer 40-item (single item, styled like your old slider trial) ----
      const TRUST40_ITEMS = [
        { id: 'act_consistently', text: 'act consistently', rc: false },
        { id: 'protect_people', text: 'protect people', rc: false },
        { id: 'act_as_part_of_team', text: 'act as part of the team', rc: false },
        { id: 'function_successfully', text: 'function successfully', rc: false },
        { id: 'malfunction', text: 'malfunction', rc: true },
        { id: 'clearly_communicate', text: 'clearly communicate', rc: false },
        { id: 'require_freq_maintenance', text: 'require frequent maintenance', rc: true },
        { id: 'openly_communicate', text: 'openly communicate', rc: false },
        { id: 'have_errors', text: 'have errors', rc: true },
        { id: 'better_than_novice', text: 'perform a task better than a novice human user', rc: false },
        { id: 'friend_vs_foe', text: 'know the difference between friend and foe', rc: false },
        { id: 'provide_feedback', text: 'provide feedback', rc: false },
        { id: 'adequate_decision_making', text: 'possess adequate decision-making capability', rc: false },
        { id: 'warn_risks', text: 'warn people of potential risks in the environment', rc: false },
        { id: 'meet_needs_mission', text: 'meet the needs of the mission', rc: false },
        { id: 'provide_appropriate_info', text: 'provide appropriate information', rc: false },
        { id: 'communicate_with_people', text: 'communicate with people', rc: false },
        { id: 'work_best_with_team', text: 'work best with a team', rc: false },
        { id: 'keep_classified_secure', text: 'keep classified information secure', rc: false },
        { id: 'perform_exactly_instructed', text: 'perform exactly as instructed', rc: false },
        { id: 'work_close_to_people', text: 'work in close proximity with people', rc: false },
        { id: 'tell_truth', text: 'tell the truth', rc: false },
        { id: 'many_functions', text: 'perform many functions at one time', rc: false },
        { id: 'follow_directions', text: 'follow directions', rc: false },
        { id: 'considered_part_team', text: 'be considered part of the team', rc: false },
        { id: 'responsible', text: 'be responsible', rc: false },
        { id: 'supportive', text: 'be supportive', rc: false },
        { id: 'incompetent', text: 'be incompetent', rc: true },
        { id: 'dependable', text: 'be dependable', rc: false },
        { id: 'friendly', text: 'be friendly', rc: false },
        { id: 'reliable', text: 'be reliable', rc: false },
        { id: 'pleasant', text: 'be pleasant', rc: false },
        { id: 'unresponsive', text: 'be unresponsive', rc: true },
        { id: 'autonomous', text: 'be autonomous', rc: false },
        { id: 'predictable', text: 'be predictable', rc: false },
        { id: 'conscious', text: 'be conscious', rc: false },
        { id: 'lifelike', text: 'be lifelike', rc: false },
        { id: 'good_teammate', text: 'be a good teammate', rc: false },
        { id: 'led_astray', text: 'be led astray by unexpected changes in the environment', rc: false },
        { id: 'built_to_last', text: 'be built to last', rc: false }
      ];

      function shuffleArray(a){ const b=a.slice(); for(let i=b.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[b[i],b[j]]=[b[j],b[i]];} return b; }

      // ---- Schaefer 40-item (final: fixed slider, hidden back on first item, consistent spacing/buttons) ----
      const trust40_trial = {
        type: jsPsychHtmlKeyboardResponse,
        choices: "NO_KEYS",
        on_start: function(){
          useLightUI();
          if (!window.__t40__) {
            const order = shuffleArray(TRUST40_ITEMS);
            window.__t40__ = { order, idx: 0, resp: {} };
          }
          let t40_keyHandler = null;
        },
        stimulus: `
          <div id="t40_card" style="
            display:flex; flex-direction:column; justify-content:center; align-items:center;
            min-height:100vh; padding:80px 24px; box-sizing:border-box;
          ">
            <div style="width:min(980px, 94vw); text-align:left;">

              <!-- progress counter -->
              <div id="t40_counter" style="font-size:14px; color:#666; text-align:right; margin-bottom:28px;"></div>

              <!-- fixed-height question box -->
              <div id="t40_qbox" style="
                margin:0 0 72px 0;
                min-height: 84px;
                display:flex; align-items:flex-end;
              ">
                <p id="t40_q" style="margin:0; font-size:22px; line-height:1.5;"></p>
              </div>

              <!-- slider block -->
              <div style="width:min(780px, 100%); margin: 0 auto;">
                <div id="t40_val" style="
                  text-align:center; font-variant-numeric: tabular-nums;
                  font-size:22px; margin-bottom:44px; font-weight:500;
                ">50%</div>

                <input type="range" id="t40_slider" min="0" max="100" step="10" value="50" list="t40_ticks" style="width:100%;">

                <div style="display:flex; justify-content:space-between; margin-top:32px; font-size:14px; color:#666;">
                  <span>0</span><span>10</span><span>20</span><span>30</span><span>40</span><span>50</span>
                  <span>60</span><span>70</span><span>80</span><span>90</span><span>100</span>
                </div>

                <datalist id="t40_ticks">
                  <option value="0"></option><option value="10"></option><option value="20"></option>
                  <option value="30"></option><option value="40"></option><option value="50"></option>
                  <option value="60"></option><option value="70"></option><option value="80"></option>
                  <option value="90"></option><option value="100"></option>
                </datalist>
              </div>

              <!-- buttons -->
              <div style="display:flex; justify-content:center; gap:24px; margin-top:96px;">
                <button id="t40_back" style="
                  padding:12px 28px; font-size:18px; border:none; border-radius:8px;
                  background:#e6eaf0; color:#111; cursor:pointer; display:none;
                ">Back</button>

                <button id="t40_next" style="
                  padding:12px 28px; font-size:18px; border:none; border-radius:8px;
                  background-color:#2a6ebb; color:#fff; cursor:pointer;
                  box-shadow:0 6px 18px rgba(0,0,0,0.12);
                ">Next</button>
              </div>
            </div>
          </div>
        `,
        on_load: function () {
          const S = window.__t40__;
          const qEl = document.getElementById('t40_q');
          const cnt = document.getElementById('t40_counter');
          const slider = document.getElementById('t40_slider');
          const valEl = document.getElementById('t40_val');
          const back = document.getElementById('t40_back');
          const next = document.getElementById('t40_next');

          function render(){
            const n = S.order.length, i = S.idx, it = S.order[i];
            cnt.textContent = `Item ${i+1} of ${n}`;
            qEl.innerHTML = `What percentage of the time will this robot <strong>${it.text}</strong>?`;

            const saved = S.resp[it.id];
            const startVal = (typeof saved === 'number') ? saved : 50;
            slider.value = Math.round(startVal / 10) * 10;
            valEl.textContent = slider.value + '%';

            // Hide back button if first question
            back.style.display = (i === 0) ? 'none' : 'inline-block';
            next.textContent = (i === n - 1) ? 'Finish' : 'Next';
          }

          function save(){
            const it = S.order[S.idx];
            S.resp[it.id] = Number(slider.value);
          }

          const snapTo10 = () => {
            slider.value = Math.round(Number(slider.value) / 10) * 10;
            valEl.textContent = slider.value + '%';
          };
          slider.addEventListener('input', snapTo10);
          slider.addEventListener('change', snapTo10);

          back.addEventListener('click', ()=>{
            save();
            if (S.idx > 0) {
              S.idx--;
              render();
            }
          });

          next.addEventListener('click', ()=>{
            save();
            if (S.idx < S.order.length - 1) {
              S.idx++;
              render();
            } else {
              // compute trust score + finish
              const rcIds = TRUST40_ITEMS.filter(x=>x.rc).map(x=>x.id);
              const orderIds = S.order.map(x=>x.id);
              const raw = {};
              orderIds.forEach(id => {
                raw[id] = (typeof S.resp[id]==='number') ? S.resp[id] : 0;
              });
              const scoredVec = orderIds.map(id => rcIds.includes(id) ? (100 - raw[id]) : raw[id]);
              const total = scoredVec.reduce((a,b)=>a+b,0) / orderIds.length;

              const payload = {
                trial_type: 'trust40_pre',
                trust40_order: orderIds,
                trust40_raw: raw,
                trust40_scored_vector: scoredVec,
                trust40_total_percent: total
              };
              window.__t40__ = null;
              jsPsych.finishTrial(payload);
            }
          });

          // keyboard shortcuts
          function keyHandler(e){
            if (e.key === 'ArrowRight') { slider.value = Math.min(100, Number(slider.value)+10); snapTo10(); }
            if (e.key === 'ArrowLeft')  { slider.value = Math.max(0,   Number(slider.value)-10); snapTo10(); }
            if (e.key === 'Enter') { next.click(); }
          }
          t40_keyHandler = keyHandler;
          document.addEventListener('keydown', keyHandler);
          qEl.oncleanup = () => document.removeEventListener('keydown', keyHandler);

          render();
        },
        on_finish: d => {
          if (t40_keyHandler) {
            document.removeEventListener('keydown', t40_keyHandler);
          }
          logTrialRow(d);
        }
      };


      // ---- Schaefer 14-item (single item, styled like the 40-item) ----
      // rc=true means reverse-coded
      const TRUST14_ITEMS = [
        { id: 'reliable',                    text: 'be reliable', rc: false },
        { id: 'dependable',                  text: 'be dependable', rc: false },
        { id: 'predictable',                 text: 'be predictable', rc: false },
        { id: 'act_consistently',            text: 'act consistently', rc: false },
        { id: 'function_successfully',       text: 'function successfully', rc: false },
        { id: 'provide_appropriate_info',    text: 'provide appropriate information', rc: false },
        { id: 'provide_feedback',            text: 'provide feedback', rc: false },
        { id: 'follow_directions',           text: 'follow directions', rc: false },
        { id: 'act_as_part_of_team',         text: 'act as part of the team', rc: false },
        { id: 'protect_people',              text: 'protect people', rc: false },
        { id: 'have_errors',                 text: 'have errors', rc: true },
        { id: 'malfunction',                 text: 'malfunction', rc: true },
        { id: 'require_freq_maintenance',    text: 'require frequent maintenance', rc: true },
        { id: 'unresponsive',                text: 'be unresponsive', rc: true }
      ];


      const trust14_trial = {
        type: jsPsychHtmlKeyboardResponse,
        choices: "NO_KEYS",
        on_start: function(){
          useLightUI(); // keep questionnaire on light theme
          if (!window.__t14__) {
            const order = shuffleArray(TRUST14_ITEMS);
            window.__t14__ = { order, idx: 0, resp: {} };
          }
          let t14_keyHandler = null;
        },
        stimulus: `
          <div id="t14_card" style="
            display:flex; flex-direction:column; justify-content:center; align-items:center;
            min-height:100vh; padding:80px 24px; box-sizing:border-box;
          ">
            <div style="width:min(980px, 94vw); text-align:left;">

              <!-- progress counter -->
              <div id="t14_counter" style="font-size:14px; color:#666; text-align:right; margin-bottom:28px;"></div>

              <!-- fixed-height question box -->
              <div id="t14_qbox" style="
                margin:0 0 72px 0;
                min-height: 84px;
                display:flex; align-items:flex-end;
              ">
                <p id="t14_q" style="margin:0; font-size:22px; line-height:1.5;"></p>
              </div>

              <!-- slider block -->
              <div style="width:min(780px, 100%); margin: 0 auto;">
                <div id="t14_val" style="
                  text-align:center; font-variant-numeric: tabular-nums;
                  font-size:22px; margin-bottom:44px; font-weight:500;
                ">50%</div>

                <input type="range" id="t14_slider" min="0" max="100" step="10" value="50" list="t14_ticks" style="width:100%;">

                <div style="display:flex; justify-content:space-between; margin-top:32px; font-size:14px; color:#666;">
                  <span>0</span><span>10</span><span>20</span><span>30</span><span>40</span><span>50</span>
                  <span>60</span><span>70</span><span>80</span><span>90</span><span>100</span>
                </div>

                <datalist id="t14_ticks">
                  <option value="0"></option><option value="10"></option><option value="20"></option>
                  <option value="30"></option><option value="40"></option><option value="50"></option>
                  <option value="60"></option><option value="70"></option><option value="80"></option>
                  <option value="90"></option><option value="100"></option>
                </datalist>
              </div>

              <!-- buttons -->
              <div style="display:flex; justify-content:center; gap:24px; margin-top:96px;">
                <button id="t14_back" style="
                  padding:12px 28px; font-size:18px; border:none; border-radius:8px;
                  background:#e6eaf0; color:#111; cursor:pointer; display:none;
                ">Back</button>

                <button id="t14_next" style="
                  padding:12px 28px; font-size:18px; border:none; border-radius:8px;
                  background-color:#2a6ebb; color:#fff; cursor:pointer;
                  box-shadow:0 6px 18px rgba(0,0,0,0.12);
                ">Next</button>
              </div>
            </div>
          </div>
        `,
        on_load: function () {
          const S = window.__t14__;
          const qEl    = document.getElementById('t14_q');
          const cnt    = document.getElementById('t14_counter');
          const slider = document.getElementById('t14_slider');
          const valEl  = document.getElementById('t14_val');
          const back   = document.getElementById('t14_back');
          const next   = document.getElementById('t14_next');

          function render(){
            const n = S.order.length, i = S.idx, it = S.order[i];
            cnt.textContent = `Item ${i+1} of ${n}`;
            qEl.innerHTML = `What percentage of the time will this robot <strong>${it.text}</strong>?`;

            const saved = S.resp[it.id];
            const startVal = (typeof saved === 'number') ? saved : 50;
            slider.value = Math.round(startVal / 10) * 10;
            valEl.textContent = slider.value + '%';

            back.style.display = (i === 0) ? 'none' : 'inline-block';
            next.textContent = (i === n - 1) ? 'Finish' : 'Next';
          }

          function save(){
            const it = S.order[S.idx];
            S.resp[it.id] = Number(slider.value);
          }

          const snapTo10 = () => {
            slider.value = Math.round(Number(slider.value) / 10) * 10;
            valEl.textContent = slider.value + '%';
          };
          slider.addEventListener('input', snapTo10);
          slider.addEventListener('change', snapTo10);

          back.addEventListener('click', ()=>{
            save();
            if (S.idx > 0) { S.idx--; render(); }
          });

          next.addEventListener('click', ()=>{
            save();
            if (S.idx < S.order.length - 1) {
              S.idx++; render();
            } else {
              // score (reverse-code rc items)
              const rcIds = TRUST14_ITEMS.filter(x=>x.rc).map(x=>x.id);
              const orderIds = S.order.map(x=>x.id);
              const raw = {};
              orderIds.forEach(id => { raw[id] = (typeof S.resp[id]==='number') ? S.resp[id] : 0; });
              const scoredVec = orderIds.map(id => rcIds.includes(id) ? (100 - raw[id]) : raw[id]);
              const total = scoredVec.reduce((a,b)=>a+b,0) / orderIds.length;

              const payload = {
                trial_type: 'trust14',
                trust14_order: orderIds,
                trust14_raw: raw,
                trust14_scored_vector: scoredVec,
                trust14_total_percent: total
              };
              window.__t14__ = null;
              jsPsych.finishTrial(payload);
            }
          });

          // keyboard shortcuts
          function keyHandler(e){
            if (e.key === 'ArrowRight') { slider.value = Math.min(100, Number(slider.value)+10); snapTo10(); }
            if (e.key === 'ArrowLeft')  { slider.value = Math.max(0,   Number(slider.value)-10); snapTo10(); }
            if (e.key === 'Enter')      { next.click(); }
          }
          t14_keyHandler = keyHandler;
          document.addEventListener('keydown', keyHandler);
          qEl.oncleanup = () => document.removeEventListener('keydown', keyHandler);

          render();
        },
        on_finish: d => {
          if (t14_keyHandler) {
            document.removeEventListener('keydown', t14_keyHandler);
          }
          logTrialRow(d);
        }
      };




      // ---- Intro trials ----
      const slider_trial = {
        type: jsPsychHtmlSliderResponse,
        on_start: function(){
          useLightUI();
        },
        stimulus: '<h2 style="margin-bottom:14px;text-align:center;">How much do you trust this robot right now?</h2>',
        labels: [
          '<div class="two-line-label">0<br>(never)</div>',
          '<div class="two-line-label">100<br>(always)</div>'
        ],
        min: 0, max: 100, start: 50, slider_width: 700, require_movement: true, button_label: 'Next',
        on_load: function () {
          const el = jsPsych.getDisplayElement();
          el.style.display = 'flex';
          el.style.flexDirection = 'column';
          el.style.justifyContent = 'center';
          el.style.alignItems = 'center';
          el.style.minHeight = '100vh';
          el.style.textAlign = 'center';
          const slider = el.querySelector('input[type="range"]');
          if (slider) {
            const valueDisplay = document.createElement('div');
            valueDisplay.id = 'slider-value-display';
            valueDisplay.style.margin = '6px 0 10px';
            valueDisplay.style.fontWeight = '600';
            valueDisplay.textContent = 'Selected value: ' + slider.value;
            slider.parentNode.insertBefore(valueDisplay, slider);
            slider.addEventListener('input', () => { valueDisplay.textContent = 'Selected value: ' + slider.value; });
          }
        },
        data: { trial_type: 'survey_slider' },
        on_finish: d => {
          d.slider_value = d.response;
          logTrialRow(d);
        }
      };

      // ---- Single trust slider probe ----
      // Context tag helps you later (e.g., "after_trust40_pre", "mid_block1_t5", etc.)
      function makeTrustProbeTrial(contextTag) {
        return {
          type: jsPsychHtmlKeyboardResponse, 
          choices: "NO_KEYS",
          on_start: function () { useLightUI(); },
          stimulus: `
            <div id="trust_probe_card" style="
              display:flex; flex-direction:column; justify-content:center; align-items:center;
              min-height:100vh; padding:80px 24px; box-sizing:border-box; text-align:center;">
              <div style="width:min(780px,94vw); text-align:center;">

                <!-- headline -->
                <h2 style="margin:0 0 12px 0;">Right now, how much do you trust this drone?</h2>
                <p style="margin:0 0 22px 0; color:#666;">0 = never trust · 100 = always trust</p>

                <!-- value readout -->
                <div id="trust_probe_val" style="
                  text-align:center; font-variant-numeric: tabular-nums;
                  font-size:22px; margin-bottom:44px; font-weight:500;">50%</div>

                <!-- slider -->
                <div style="width:min(780px,100%); margin:0 auto;">
                  <input type="range" id="trust_probe_slider" min="0" max="100" step="10" value="50" list="trust_probe_ticks" style="width:100%;">
                  <div style="display:flex; justify-content:space-between; margin-top:32px; font-size:14px; color:#666;">
                    <span>0</span><span>10</span><span>20</span><span>30</span><span>40</span><span>50</span>
                    <span>60</span><span>70</span><span>80</span><span>90</span><span>100</span>
                  </div>
                  <datalist id="trust_probe_ticks">
                    <option value="0"></option><option value="10"></option><option value="20"></option>
                    <option value="30"></option><option value="40"></option><option value="50"></option>
                    <option value="60"></option><option value="70"></option><option value="80"></option>
                    <option value="90"></option><option value="100"></option>
                  </datalist>
                </div>

                <!-- button -->
                <div style="display:flex; justify-content:center; margin-top:96px;">
                  <button id="trust_probe_next" style="
                    padding:12px 28px; font-size:18px; border:none; border-radius:8px;
                    background-color:#2a6ebb; color:#fff; cursor:pointer;
                    box-shadow:0 6px 18px rgba(0,0,0,0.12);
                  ">Continue</button>
                </div>
              </div>
            </div>
          `,
          on_load: function () {
            const slider = document.getElementById('trust_probe_slider');
            const valEl = document.getElementById('trust_probe_val');
            const next = document.getElementById('trust_probe_next');

            // Live snapping + value update
            const snapTo10 = () => {
              slider.value = String(Math.round(Number(slider.value) / 10) * 10);
              valEl.textContent = `${slider.value}%`;
            };
            slider.addEventListener('input', snapTo10);
            slider.addEventListener('change', snapTo10);

            // Keyboard shortcuts (same as questionnaire)
            function keyHandler(e) {
              if (e.key === 'ArrowRight') { slider.value = String(Math.min(100, Number(slider.value) + 10)); snapTo10(); }
              if (e.key === 'ArrowLeft')  { slider.value = String(Math.max(0, Number(slider.value) - 10)); snapTo10(); }
              if (e.key === 'Enter')      { next.click(); }
            }
            document.addEventListener('keydown', keyHandler);
            next.addEventListener('click', () => {
              document.removeEventListener('keydown', keyHandler);
              jsPsych.finishTrial({
                trial_type: 'trust_probe',
                probe_context: contextTag,
                slider_value: Number(slider.value)
              });
            });
          },
          on_finish: d => { logTrialRow(d); }
        };
      }



      const emergency_trial = {
        type: jsPsychHtmlButtonResponse,
        on_start: function(){
          useLightUI();
        },
        stimulus: '<h2 style="margin-bottom:18px;text-align:center;">In an emergency situation, whose judgement do you generally trust more?</h2>',
        choices: ["My own judgement", "A rescue robot's judgement"],
        on_load: function () {
          const el = jsPsych.getDisplayElement();
          el.style.display = 'flex';
          el.style.flexDirection = 'column';
          el.style.justifyContent = 'center';
          el.style.alignItems = 'center';
          el.style.minHeight = '100vh';
          el.style.textAlign = 'center';
        },
        data: { trial_type: 'survey_button' },
        on_finish: d => {
          d.choice = d.response;
          logTrialRow(d);
        }
      };

      // ---- Reputation probe (single, discrete) ----
      // Encodes much worse=-2, worse=-1, no change=0, better=+1, much better=+2
      const reputation_probe_trial = {
        type: jsPsychHtmlButtonResponse,
        on_start: () => { useLightUI(); },
        stimulus: '<h2 style="margin-bottom:12px;text-align:center;">How did these reviews change your opinion of the drone?</h2><p style="margin-bottom:10;text-align:center;">My opinion on this drone is now:</p>',
        choices: [
          "Much worse",
          "Worse",
          "The same",
          "Better",
          "Much better"
        ],
        on_load: function () {
          // Ensure jsPsych's wrapper also centers vertically
          const el = jsPsych.getDisplayElement();
          el.style.display = 'flex';
          el.style.flexDirection = 'column';
          el.style.justifyContent = 'center';
          el.style.alignItems = 'center';
          el.style.minHeight = '100vh';
          el.style.textAlign = 'center';
        },
        data: { trial_type: 'reputation_probe' },
        on_finish: d => {
          const map = [-2, -1, 0, 1, 2];
          d.reputation_probe_choice = d.response;  // 0..4 button index
          d.reputation_probe_delta  = map[d.response];  // -2..+2 semantic code
          logTrialRow(d);
        }
      };


      const ready_trial = {
        type: jsPsychHtmlButtonResponse,
        on_start: function(){
          useLightUI();
        },
        stimulus: '<h2 style="margin-bottom:8px;text-align:center;">You are ready to proceed.</h2><p style="margin:0;text-align:center;">Press Continue to start the main task.</p>',
        choices: ['Continue'],
        on_load: function () {
          const el = jsPsych.getDisplayElement();
          el.style.display = 'flex';
          el.style.flexDirection = 'column';
          el.style.justifyContent = 'center';
          el.style.alignItems = 'center';
          el.style.minHeight = '100vh';
          el.style.textAlign = 'center';
        },
      };

      
      timeline.push(
        overview_trial,
        robot_description_trial,
        trust40_trial,
        makeTrustProbeTrial('after_trust40_pre'),
        emergency_trial,

        // fade stays light; show reviews
        // (no fade needed here; trust40 already uses light UI)
      );

      // Load reviews data and build the review trials (do this after assets preload & CONFIG)
      const REVIEWS = await loadReviewsJSON();
      let reviewsTrial = null;
      if (REVIEWS) {
        const cond = CONFIG.review_condition; // may be null -> random
        const set  = pickReviewSet(REVIEWS, cond, RAND);
        const expected = CONFIG.review_expected_map[(cond || 'mixed')];
        const reviewSetWithAvatars = assignAvatarsToReviewSet(set, RAND);
        reviewsTrial = make_reviews_trial({ reviewSet: reviewSetWithAvatars, condition: (cond || 'random'), expectedReputation: expected });
        timeline.push(reviewsTrial, reputation_probe_trial);
      }

      // keep your quick questions afterwards if you want them
      timeline.push(
        ready_trial,
        {
          type: jsPsychHtmlKeyboardResponse,
          choices: "NO_KEYS",
          on_start: () => { useLightUI(); },
          stimulus: `
            <div style="min-height:100vh;display:flex;align-items:center;justify-content:center;padding:40px;">
              <div style="max-width:900px;text-align:left;">
                <h2 style="margin:0 0 10px 0;">Brief demonstration</h2>
                <p style="margin:0 0 8px 0;">
                  Next, you will see a <strong>single demonstration</strong> of the main task. You will be shown how the drone <em>enters</em> the scene, <em>scans both doors,</em> and <em>positions</em> itself above the <em>recommended</em> door. At each search area, one victim is always located behind one of the doors. Due to the risk of fire spreading, there is only time to open one door before moving to the next area. The goal of the mission is to find as many victims as possible. During the demonstration, you will not have to make any choices and no outcomes will be shown.
                </p>
                <p style="margin:0 0 8px 0;">
                  After the demonstration, the main task will begin automatically. At each search area, you will be prompted to either follow or not follow the drone's recommendation. You can answer by clicking the buttons that will appear onscreen, or by pressing <strong>F</strong> (to follow the drone's recommendation) or <strong>N</strong> (to not follow the drone's recommendation) on your keyboard. After your decision the respective door will be opened, revealing if a victim has been found or not.
                </p>
                <p style="margin:0 0 16px 0;">
                  Throughout the main task you may also be prompted to aswer some questions.
                </p>
                <div style="margin-top:20px;">
                  <button id="demo-continue" style="
                    padding:12px 24px;border:none;border-radius:8px;background:#2a6ebb;color:#fff;font-weight:700;cursor:pointer;">
                    Continue
                  </button>
                </div>
              </div>
            </div>
          `,
          on_load: () => {
            document.getElementById('demo-continue')?.addEventListener('click', () => jsPsych.finishTrial());
          },
          data: { trial_type: 'training_intro' },
          on_finish: d => { logTrialRow(d); }
        }
      );



      // ---- Trial generation (uses RAND) ----
      function generateRandomTrials(N, successRate) {
        const out = [];
        for (let i = 0; i < N; i++) {
          const true_location = RAND() < 0.5 ? 'left' : 'right';
          const correct = RAND() < successRate;
          const suggestion = correct ? true_location : (true_location === 'left' ? 'right' : 'left');
          out.push({ true_location, suggestion });
        }
        return out;
      }

      function generateTrainingTrials(N, randFn) {
        const out = [];
        for (let i = 0; i < N; i++) {
          // random left/right for true_location; suggestion random too
          const true_location = randFn() < 0.5 ? 'left' : 'right';
          const suggestion    = randFn() < 0.5 ? 'left' : 'right';

          // background, doors, fx, victim (victim never revealed in demo)
          const background_src = pickBackground();
          const door_src       = pickDoorSkin();
          const { left: smoke_left_src, right: smoke_right_src } = nextSmokePair();
          const { left: fire_left_src,  right: fire_right_src  } = nextFirePair();

          out.push({
            true_location,
            suggestion,
            victim_src: pickVictimSkin(),
            envWarmth: CONFIG.env_warmth || 'warm',
            background_src,
            door_src,
            smoke_left_src,
            smoke_right_src,
            fire_left_src,
            fire_right_src
          });
        }
        return out;
      }



      // Load 1–3 blocks from A–H, with single-link auto assignment
      async function loadTrialsBlocks() {
        // 0) Optional URL override for debugging
        if (CONFIG.allow_url_override) {
          const sp = new URLSearchParams(location.search);
          const urlSet = sp.get('set');
          if (urlSet) CONFIG.set_id = urlSet;
        }

        // 1) If we already have a set (from localStorage or URL), use it
        const stored = localStorage.getItem(CONFIG.local_key);
        if (!CONFIG.set_id && stored) CONFIG.set_id = stored;

  
        // 2) Load the sets file (A–H)
        const url = new URL('conditions/sets_v1.json', window.location.href);
        const res = await fetch(url, { cache: 'no-store' }).catch(e => {
                  console.error('Fetch error:', e);
                  throw e;
                });
        if (!res.ok) throw new Error(`Failed to load sets_v1.json (${res.status})`);
        const allSets = await res.json();
        const setIds = Object.keys(allSets);

        // 3) If still no set, pick one (deterministically from participant code or random)
        if (!CONFIG.set_id) {
          const code = getParticipantCode(); // returns null if you didn’t add an input field
          if (code) {
            const bucket = hashToBucket(code, setIds.length);
            CONFIG.set_id = setIds[bucket];
          } else {
            // random assign if no code given
            CONFIG.set_id = setIds[Math.floor(Math.random() * setIds.length)];
          }
          localStorage.setItem(CONFIG.local_key, CONFIG.set_id);
        }

        const chosen = allSets[CONFIG.set_id];
        if (!chosen || !Array.isArray(chosen.blocks) || chosen.blocks.length === 0) {
          throw new Error(`Set '${CONFIG.set_id}' not found or malformed.`);
        }

        // Normalize into our internal structure
        const blocks = chosen.blocks.map(blk => ({
          trials: (blk.trials || []).map(row => ({
            true_location: (row.victim === 'L' ? 'left' : 'right'),
            suggestion:    (row.suggestion === 'L' ? 'left' : 'right'),
            risk_key:      row.risk || null
          })),
          probes: Array.isArray(blk.probes) ? blk.probes.slice() : null
        }));

        return { mode:'set', blocks, set_id: CONFIG.set_id };
      }


      // === New: per-trial augmentation that respects pre-defined risk_key ===
      function augmentTrials(trials) {
        return trials.map(t => {
          const background_src = pickBackground();
          const door_src       = pickDoorSkin();
          const { left: smoke_left_src, right: smoke_right_src } = nextSmokePair();
          const { left: fire_left_src,  right: fire_right_src  } = nextFirePair();

          // Prefer predefined risk_key; otherwise draw randomly (25/35/25/15)
          const rk = t.risk_key || ((() => {
            const r = RAND();
            return (r < 0.25) ? 'low' : (r < 0.60) ? 'medium' : (r < 0.85) ? 'high' : 'extreme';
          })());

          const baseTimeout   = (window.CONFIG.decision_timeout_ms ?? 4000);
          const risk_overrides = makeRiskOverrides(rk, baseTimeout, window.CONFIG);

          return {
            ...t,
            victim_src: pickVictimSkin(),
            envWarmth:   risk_overrides.warmth,
            risk_value:  risk_overrides.risk_value,
            background_src,
            door_src,
            smoke_left_src,
            smoke_right_src,
            fire_left_src,
            fire_right_src,
            risk_overrides
          };
        });
      }


      // ---- Layout + scene HTML ----
      const layout = { leftDoorX: 479, leftDoorY: 248, rightDoorX: 1132, rightDoorY: 248, arrowOffsetY: -80 };

      function build_scene_html({
        suggestion = 'none',
        true_location = null,
        trial_num = 1,
        trial_total = 1,
        background_src,
        door_src,
        smoke_left_src,
        smoke_right_src,
        fire_left_src,
        fire_right_src
      }) {
        const leftArrowHtml  = '';
        const rightArrowHtml = '';
        const droneHtml = `
          <div class="overlay-drone">
            <img src="assets/drone.png" class="drone-body" alt="Drone">
            <div class="rotor rotor-left"><div class="disc"></div></div>
            <div class="rotor rotor-right"><div class="disc"></div></div>
          </div>`;
        return `
          <div class="scene-root" style="opacity:0" data-true="${true_location}">
            <div class="scene-frame">
              <div class="trial-counter">
                <span class="tc-label">Search Area</span>
                <span class="tc-index">${trial_num}</span>
                <span class="tc-of">of</span>
                <span class="tc-total">${trial_total}</span>
              </div>
              <img src="${background_src}" class="background" alt="">
              <!-- FX layers (foreground, above drone, below HUD) -->
              <img src="${smoke_left_src}"  class="fx-layer smoke-left"  alt="" aria-hidden="true">
              <img src="${smoke_right_src}" class="fx-layer smoke-right" alt="" aria-hidden="true">
              <img src="${fire_left_src}"   class="fx-layer fire-left"   alt="" aria-hidden="true">
              <img src="${fire_right_src}"  class="fx-layer fire-right"  alt="" aria-hidden="true">
              <img src="assets/empty.png" class="revealed-image left-revealed" data-side="left" alt="">
              <img src="assets/empty.png" class="revealed-image right-revealed" data-side="right" alt="">
              <div class="overlay left-door" data-orig-x="${layout.leftDoorX}" data-orig-y="${layout.leftDoorY}">
                ${leftArrowHtml}
                <img src="${door_src}" class="door-image" alt="">
              </div>
              <div class="overlay right-door" data-orig-x="${layout.rightDoorX}" data-orig-y="${layout.rightDoorY}">
                ${rightArrowHtml}
                <img src="${door_src}" class="door-image" alt="">
              </div>
              ${droneHtml}


              <div id="decision-box">
                <!-- Buttons FIRST (above the slider) -->
                <div class="decision-controls">
                  <button id="btn-follow" class="primaryBtn">Follow drone (F)</button>
                  <button id="btn-ignore" class="secondaryBtn">Choose other door (N)</button>
                </div>

                <p id="decision-text" style="margin-top:2px;">The drone recommends …</p>

                <!-- Environmental Integrity row (slider) BELOW the buttons -->
                <div class="env-row" style="margin-bottom:6px;">
                  <div class="env-label">Environmental Integrity</div>
                  <div class="env-wrap"><div class="env-fill" id="env-fill"></div></div>
                  <div class="env-pct" id="env-pct">100%</div>
                </div>
              </div>
              <div id="mission-panel" class="mission-panel" aria-live="polite" aria-atomic="true">
                <div class="mp-badge" id="mp-badge">SUCCESS</div>
                <div class="mp-title" id="mp-title">Victim Found</div>
              </div>
            </div> 
          </div>`;
      }

      // ---- Reviews (5 cards on one screen, reveal in quick succession) ----
      function make_reviews_trial({ reviewSet, condition, expectedReputation }) {
        return {
          type: jsPsychHtmlKeyboardResponse,
          choices: "NO_KEYS",
          on_start: () => { useLightUI(); },
          stimulus: `
            <div style="
              min-height:100vh; display:flex; align-items:center; justify-content:center;
              padding:32px 18px; box-sizing:border-box;">
              <div style="width:min(980px,94vw);">
                <h2 style="margin:0 0 12px 0; text-align:center;">What other rescuers say</h2>
                <p style="margin:0 0 22px 0; color:#555; text-align:center;">
                  The following short reviews summarize experiences from other team members using this drone.
                </p>

                <!-- FLEX WRAP: last row auto-centers -->
                <div id="rv-grid" style="
                  display:flex; flex-wrap:wrap; justify-content:center; align-items:stretch;
                  gap:14px; margin:0 auto; width:100%;
                ">
                  ${reviewSet.map((r) => `
                    <div class="rv-card" data-id="${r.id}" style="
                    width: 300px; max-width: 92vw;
                    display:flex; gap:16px; align-items:center;
                    background:#fff; border-radius:12px; padding:14px; box-shadow:0 6px 20px rgba(10,10,20,.06);
                    opacity:0; transform: translateY(8px);
                    transition: opacity 220ms ease, transform 220ms cubic-bezier(.2,.9,.1,1);">
                    <!-- avatar -->
                    <img src="${r.avatar?.src || ''}" alt="" style="
                      width:84px; height:84px; border-radius:50%; object-fit:cover; background:#e9eef6;
                      display:block;
                      flex:0 0 auto;">
                    <!-- TEXT ONLY -->
                    <div style="flex:1 1 auto;">
                      <div style="font-size:15px; line-height:1.4; color:#333;">${r.text}</div>
                    </div>
                  </div>
                `).join('')}
              </div>

                <div style="display:flex; justify-content:center; margin-top:22px;">
                  <button id="rv-continue" disabled aria-disabled="true" style="
                    padding:10px 20px; border:none; border-radius:10px;
                    background:#2a6ebb; color:#fff; font-weight:700;
                    cursor:not-allowed; opacity:.55;">
                    Continue
                  </button>
                </div>
              </div>
            </div>
          `,
          on_load: () => {
            const cards = Array.from(document.querySelectorAll('.rv-card'));
            const step  = (window.CONFIG?.review_reveal_stagger_ms ?? 220);
            const btn   = document.getElementById('rv-continue');

            // Staggered reveal
            cards.forEach((el, i) => {
              setTimeout(() => {
                el.style.opacity = '1';
                el.style.transform = 'translateY(0)';
              }, i * step);
            });

            // Enable Continue after the last reveal finishes (last stagger + ~transition time)
            const transitionMs = 240;
            const totalRevealMs = (cards.length - 1) * step + transitionMs + 60;
            setTimeout(() => {
              btn.disabled = false;
              btn.setAttribute('aria-disabled', 'false');
              btn.style.opacity = '1';
              btn.style.cursor  = 'pointer';
            }, Math.max(0, totalRevealMs));

            btn.addEventListener('click', () => {
              if (btn.disabled) return; // extra guard
              jsPsych.finishTrial();
            });
          },
          data: {
            trial_type: 'reviews_set',
            review_condition: condition,
            review_expected: expectedReputation,
            review_ids: reviewSet.map(r => r.id).join(','),
            review_tones: reviewSet.map(r => r.tone).join(','),
            review_avatars: reviewSet.map(r => `${r.avatar?.baseId || ''}:${r.avatar?.mood || ''}`).join(',')
          },
          on_finish: d => { logTrialRow(d); }
        };
      }


      function make_door_trial(t, idx, total, opts = {}){
        return {
          type: jsPsychHtmlKeyboardResponse,
          on_start: function(){
          useDarkUI();
        },
          stimulus: function(){ 
            let html = build_scene_html({
              suggestion: t.suggestion,
              true_location: t.true_location,
              trial_num: idx + 1,
              trial_total: total,
              background_src: t.background_src,
              door_src:       t.door_src,
              smoke_left_src: t.smoke_left_src,
              smoke_right_src:t.smoke_right_src,
              fire_left_src:  t.fire_left_src,
              fire_right_src: t.fire_right_src
            });
            return html.replace('<div class="scene-root"', '<div class="scene-root" style="opacity:0"');
          },
          choices: "NO_KEYS",
          response_ends_trial: false,
          trial_duration: null,
          data: { ...t, trial_index: idx, trial_total: total },
          on_load: function(){
            window.__LOCK_FX_LAYOUT__ = false;
            lockScroll();
            setDisplayBg('#000');
            const frame  = jsPsych.getDisplayElement();
            const rootEl = frame.querySelector('.scene-root');
            const IS_LAST = (idx === total - 1);
            const IS_TRAINING = !!opts.training;
            const IS_DEMO     = !!opts.demo;   // <-- new: descriptive demo mode
            // apply trial warmth (or the global config if forced)
            const warmth = t.envWarmth || CONFIG.env_warmth || 'warm';
            if (rootEl) {
              rootEl.classList.remove('warmth-cool','warmth-warm','warmth-hot');
              rootEl.classList.add(`warmth-${warmth}`);
            }

            try {
              const smL = frame.querySelector('.smoke-left');
              const smR = frame.querySelector('.smoke-right');
              const fiL = frame.querySelector('.fire-left');
              const fiR = frame.querySelector('.fire-right');
              if (smL && t.smoke_left_src)  smL.src  = t.smoke_left_src;
              if (smR && t.smoke_right_src) smR.src  = t.smoke_right_src;
              if (fiL && t.fire_left_src)   fiL.src  = t.fire_left_src;
              if (fiR && t.fire_right_src)  fiR.src  = t.fire_right_src;
            } catch(_){}

            // --- Risk overrides (per-trial), applied to CONFIG during this trial only ---
            const _cfg = window.CONFIG;
            const _savedFx = {
              fire_inward_px: _cfg.fire_inward_px,
              smoke_inward_px: _cfg.smoke_inward_px,
              smoke_rise_px: _cfg.smoke_rise_px
            };
            if (t.risk_overrides) {
              _cfg.fire_inward_px  = t.risk_overrides.fire_inward_px;
              _cfg.smoke_inward_px = t.risk_overrides.smoke_inward_px;
              _cfg.smoke_rise_px   = t.risk_overrides.smoke_rise_px;
            }


            position_scene_overlays(frame).then(()=>{
              // ===== Overlay label for demonstration mode =====
              if (IS_DEMO) {
                const overlayLabel = document.createElement('div');
                overlayLabel.textContent = 'Demonstration – no interaction required';
                Object.assign(overlayLabel.style, {
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  transform: 'translate(-50%, -50%)',
                  color: 'white',
                  fontSize: '32px',
                  fontWeight: '700',
                  textShadow: '0 0 10px rgba(0,0,0,0.8)',
                  background: 'rgba(0,0,0,0.35)',
                  padding: '12px 24px',
                  borderRadius: '12px',
                  pointerEvents: 'none',
                  zIndex: '9999',
                  textAlign: 'center'
                });
                frame.appendChild(overlayLabel);

                // fade out the overlay before the trial ends (so it doesn’t persist between scenes)
                setTimeout(() => {
                  overlayLabel.style.transition = 'opacity 800ms ease';
                  overlayLabel.style.opacity = '0';
                  setTimeout(() => overlayLabel.remove(), 900);
                }, 2500); // visible for ~2.5 seconds
              }

              const pendingTO = [];
              const setTO = (fn, ms) => {
                const id = setTimeout(fn, ms);
                pendingTO.push(id);
                return id;
              };

              const cleanup = attach_positioning(frame);

              const true_location = rootEl ? rootEl.getAttribute('data-true') : null;

              const leftRevealed  = frame.querySelector('.left-revealed');
              const rightRevealed = frame.querySelector('.right-revealed');
              const skin = t.victim_src || pickVictimSkin(); // from closure
              if (IS_DEMO) {
                if (leftRevealed)  leftRevealed.src  = 'assets/empty.png';
                if (rightRevealed) rightRevealed.src = 'assets/empty.png';
              } else {
                if (leftRevealed)  leftRevealed.src  = (true_location === 'left')  ? skin : 'assets/empty.png';
                if (rightRevealed) rightRevealed.src = (true_location === 'right') ? skin : 'assets/empty.png';
              }
              if (leftRevealed)  leftRevealed.style.visibility  = 'hidden';
              if (rightRevealed) rightRevealed.style.visibility = 'hidden';


              

              // Show scene
              requestAnimationFrame(()=>{ rootEl.style.opacity = '1'; });

              // FX anim state (slide-in across the whole trial)
              let fxRaf = null;
              let fxStart = null;
              let fxStopped = false;

              // ---- FX total duration (fire/smoke motion) ----
              // Use a "worst case" scenario that safely exceeds all normal phases,
              // so fire/smoke keep animating until relocation.
              const approxVisibleMs =
                (CONFIG.drone_entry_ms       ?? 2500) +   // entry flight
                (CONFIG.drone_prebuffer_ms   ?? 1000) +
                (CONFIG.drone_buffer_ms      ?? 1200) +   // scanning
                (CONFIG.drone_anim_ms        ?? 1200) +   // hop to door
                (CONFIG.decision_timeout_ms  ?? 5000) +   // user time window (max)
                2000 /* door open + banner hold */ +
                2500 /* safety buffer so FX continues through blackout */;


              // If you want it to start at the moment we fade-in, set fxStart when we show the scene:
              function startFxLoop(){
                fxStart = performance.now();
                const ease = x => x; // linear by default; swap for easeInOut if you like
                function tick(now){
                  if (fxStopped) return;
                  const raw = Math.max(0, Math.min(1, (now - fxStart) / approxVisibleMs));
                  const p = ease(raw);
                  window.__fxProgress = p;          // used by resize & reflows


                  const fn = window.__applyFxProgressPosition;
                  if (typeof fn === 'function') fn(p);

                  fxRaf = requestAnimationFrame(tick);
                }
                fxRaf = requestAnimationFrame(tick);
              }
              startFxLoop();


              // Elements we’ll use
              const leftDoorOverlay   = frame.querySelector('.left-door');
              const rightDoorOverlay  = frame.querySelector('.right-door');
              const droneEl           = frame.querySelector('.overlay-drone');
              const decisionBox       = frame.querySelector('#decision-box');
              const decisionText      = frame.querySelector('#decision-text');
              const btnFollow         = frame.querySelector('#btn-follow');
              const btnIgnore         = frame.querySelector('#btn-ignore');
              const suggestion = t.suggestion;               // 'left' | 'right'
              const trialStart = performance.now();
              let responded = false;

              let timerId = null;      // shared timer handle
              let timedOut = false;    // shared timeout flag

              // --- helpers: read/write left/top, WAAPI move, wait
              function getLT(el){
                const cs = getComputedStyle(el);
                return {
                  left: parseFloat(cs.left) || 0,
                  top:  parseFloat(cs.top)  || 0
                };
              }
              function moveTo(el, toLeft, toTop, durationMs, easing = 'linear'){
                return new Promise((resolve) => {
                  const from = getLT(el);
                  const keyframes = (typeof toTop === 'number')
                    ? [{ left: from.left + 'px', top: from.top + 'px' },
                      { left: toLeft + 'px',    top: toTop + 'px' }]
                    : [{ left: from.left + 'px' },
                      { left: toLeft + 'px' }];

                  const anim = el.animate(keyframes, {
                    duration: Math.max(0, durationMs),
                    easing,
                    fill: 'forwards',
                    composite: 'replace'
                  });

                  const finish = () => {
                    if (typeof toLeft === 'number') el.style.left = toLeft + 'px';
                    if (typeof toTop  === 'number') el.style.top  = toTop  + 'px';
                    resolve();
                  };
                  anim.addEventListener?.('finish', finish, { once: true });
                  anim.finished?.then(finish).catch(finish);
                });
              }
              function moveTransformTo(el, toX, toY, durationMs, easing = 'cubic-bezier(.3,.3,.9,1)') {
                const fromX = parseFloat(el.style.getPropertyValue('--tx')) || 0;
                const fromY = parseFloat(el.style.getPropertyValue('--ty')) || 0;

                const wasPaused = el.classList.contains('paused');
                el.classList.add('paused'); // freeze hover phase

                const anim = el.animate(
                  [
                    { transform: `translate(${fromX}px, ${fromY}px) translateY(0px)` },
                    { transform: `translate(${toX}px, ${toY}px) translateY(0px)` }
                  ],
                  { duration: Math.max(0, durationMs), easing, fill: 'forwards' }
                );

                return anim.finished.catch(()=>{}).then(() => {
                  el.style.setProperty('--tx', `${toX}px`);
                  el.style.setProperty('--ty', `${toY}px`);
                  anim.cancel();
                  if (!wasPaused) el.classList.remove('paused'); // resume hover exactly at the settled base
                });
              }

              const wait = (ms) => new Promise(r => setTimeout(r, ms));


              // ----- DRONE ENTRY FROM LEFT (constant speed, then start scan) -----
              const frameEl  = frame.querySelector('.scene-frame');
              const frameRect= frameEl.getBoundingClientRect();

              // where the drone should hover while idle (center between doors, vertically centered)
              const mid = doorMidX(leftDoorOverlay, rightDoorOverlay);

              // force-measure drone size
              const droneRect0 = droneEl.getBoundingClientRect();
              const droneW = droneRect0.width  || parseFloat(droneEl.style.width)  || 120;
              const droneH = droneRect0.height || parseFloat(droneEl.style.height) || 100;

              const centerLeft = Math.round(mid - droneW/2);
              const centerTop  = Math.round((frameRect.height - droneH)/2);

              // start off-screen left; keep hover attached but paused (no transform reset)
              droneEl.classList.add('hovering', 'paused');
              droneEl.style.top  = centerTop + 'px';
              droneEl.style.left = (-droneW - 30) + 'px';

              // force reflow so the browser “commits” this start position
              void droneEl.offsetWidth;

                            
              // Position helpers for the decision box baseline (door bottom mid)
              function doorBottom(overlayEl){
                const t = parseFloat(overlayEl.style.top)   || 0;
                const h = parseFloat(overlayEl.style.height)|| 0;
                return t + h;
              }
              function doorMidX(leftOv, rightOv){
                const l = parseFloat(leftOv.style.left)  || 0;
                const lw= parseFloat(leftOv.style.width) || 0;
                const r = parseFloat(rightOv.style.left) || 0;
                const rw= parseFloat(rightOv.style.width)|| 0;
                return (l + lw/2 + r + rw/2) / 2;
              }

              //  Countdown controller (one timer from scan-decision end)
              let rafId = null;
              let t0 = null;                 // scan start time
              let totalMs = null;            // prebuffer + scan + transit + decision
              let shouldAutoFollow = false;  // if true and controls aren't up yet, auto-follow on reveal

              //  Integrity bar refs
              const envFill = frame.querySelector('#env-fill');
              const envPct  = frame.querySelector('#env-pct');

              // Color & rhythm utilities (reuse your existing versions)
              // --- Blue → White → Red (only) ---
              // endpoints (you can tweak these if you like)
              const BAR_BLUE = '#103a75';  // blue
              const BAR_RED  = '#d30000';  // red
              const BAR_WHITE = '#ffffff';

              function hexToRgb(hex){
                const h = hex.replace('#','');
                const v = h.length === 3
                  ? h.split('').map(x => x + x).join('')
                  : h;
                const r = parseInt(v.slice(0,2), 16);
                const g = parseInt(v.slice(2,4), 16);
                const b = parseInt(v.slice(4,6), 16);
                return { r, g, b };
              }
              function mixRgb(a, b, t){
                const lerp = (x,y,t) => x + (y - x) * t;
                return {
                  r: Math.round(lerp(a.r, b.r, t)),
                  g: Math.round(lerp(a.g, b.g, t)),
                  b: Math.round(lerp(a.b, b.b, t)),
                };
              }
              function rgbToCss({r,g,b}){ return `rgb(${r}, ${g}, ${b})`; }
              function rgbaToCss({r,g,b}, a){ return `rgba(${r}, ${g}, ${b}, ${a})`; }

              // Map 0..1 to 0..1, symmetric around 0.5, faster through the middle.
              // Increase s to spend even LESS time near white.
              function speedUpAroundMid(f, s = 4.0){
                const x = 2*f - 1;                         // -1..1 with 0 at the midpoint
                const y = Math.tanh(s * x) / Math.tanh(s); // -1..1, steepest near 0
                return 0.5 * (y + 1);                       // back to 0..1, midpoint preserved
              }

              // Turn 'rgb(r,g,b)' or 'rgba(r,g,b,*)' into 'rgba(r,g,b,a)'
              function withAlpha(rgbCss, alpha){
                const m = rgbCss.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (!m) return rgbCss;
                const [_, r, g, b] = m;
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
              }


              // Return ONLY blue→white→red; no other hues
              function colorFor(frac){
                // "frac" is your bar fill (0..1). If you were inverting earlier, do it here:
                const f = 1 - frac; 

                // Speed up around the white midpoint, but keep midpoint at 0.5
                const u = speedUpAroundMid(f, 2.0);

                if (u <= 0.5){
                  const t = u / 0.5; // 0..1 in the blue→white half
                  return rgbToCss(mixRgb(hexToRgb(BAR_BLUE), hexToRgb(BAR_WHITE), t));
                } else {
                  const t = (u - 0.5) / 0.5; // 0..1 in the white→red half
                  return rgbToCss(mixRgb(hexToRgb(BAR_WHITE), hexToRgb(BAR_RED), t));
                }
              }
              function updatePct(frac){
                if (!CONFIG.env_show_pct || !envPct) return;
                envPct.textContent = Math.round(frac * 100) + '%';
              }
              function renderIntegrity(msLeft){
                const frac = Math.max(0, Math.min(1, msLeft / totalMs));

                // box glow — match the bar color 1:1 
                const barColor = colorFor(frac); 
                if (decisionBox){
                  decisionBox.style.setProperty('--glow-color',        withAlpha(barColor, 0.25));
                  decisionBox.style.setProperty('--glow-strong-color', withAlpha(barColor, 0.45));
                }

                // bar fill
                if (envFill){
                  envFill.style.transform = `scaleX(${frac})`;
                  envFill.style.background = colorFor(frac);
                }
                updatePct(frac);

                // thresholds + rhythm
                const TH = (CONFIG.env_pulse_threshold ?? 0.30);
                const inRedZone = frac <= TH;

                const periodMs = Math.round(1100 - 400 * (1 - frac));
                if (decisionBox) decisionBox.style.setProperty('--hb-period', periodMs + 'ms');
                if (rootEl)      rootEl.style.setProperty('--hb-period', periodMs + 'ms');

                if (envFill){
                  if (inRedZone) envFill.classList.add('pulse');
                  else           envFill.classList.remove('pulse');
                }
                if (decisionBox){
                  if (inRedZone) decisionBox.classList.add('heartbeat');
                  else           decisionBox.classList.remove('heartbeat');
                }
                if (rootEl){
                  if (inRedZone) rootEl.classList.add('warmth-flicker');
                  else           rootEl.classList.remove('warmth-flicker');
                }
              }
              function stopIntegrity(){
                if (rafId){ cancelAnimationFrame(rafId); rafId = null; }
                if (envFill) envFill.classList.remove('pulse');
                if (decisionBox){
                  decisionBox.classList.remove('heartbeat');
                  decisionBox.style.removeProperty('--hb-period');
                }
                if (rootEl){
                  rootEl.classList.remove('warmth-flicker');
                  rootEl.style.removeProperty('--hb-period');
                }
              }
              
              // Pieces that don't depend on entry timing
              const preMs   = (CONFIG.drone_prebuffer_ms ?? 1000);
              const scanMs  = (typeof t.buffer_ms === 'number') ? t.buffer_ms : CONFIG.drone_buffer_ms;
              const transit = (typeof CONFIG.drone_anim_ms === 'number') ? CONFIG.drone_anim_ms : 1100;
              const decide  = IS_DEMO ? 0
                : (t.risk_overrides?.decision_timeout_ms ?? CONFIG.decision_timeout_ms ?? 0);


              // position the box on the door baseline, compact mode, visible
              if (!IS_DEMO && decisionBox && leftDoorOverlay && rightDoorOverlay){
                decisionBox.classList.add('compact');
                // temporarily show to measure compact height
                decisionBox.classList.add('hud-show');
                decisionBox.style.opacity = '0'; // no flash while placing

                const frameEl = frame.querySelector('.scene-frame');
                const frameRect = frameEl.getBoundingClientRect();

                // --- Camera shake (risk) ---
                try {
                  const sf = frame.querySelector('.scene-frame');
                  if (sf && t.risk_overrides) {
                    const amp = t.risk_overrides.shake_amp_px ?? 0;
                    const period = t.risk_overrides.shake_period_ms ?? 900;

                    if (amp > 0) {
                      sf.classList.add('risk-shake');
                      sf.style.setProperty('--shake-amp', amp + 'px');
                      sf.style.setProperty('--shake-period', period + 'ms');
                    } else {
                      sf.classList.remove('risk-shake');
                      sf.style.removeProperty('--shake-amp');
                      sf.style.removeProperty('--shake-period');
                    }
                  }
                } catch(_) {}


                const baseY = Math.round(Math.max(doorBottom(leftDoorOverlay), doorBottom(rightDoorOverlay)));

                requestAnimationFrame(()=>{
                  const bottomOffset = Math.max(0, frameRect.height - baseY);
                  decisionBox.style.left = '50%';             // ← center in the frame
                  decisionBox.style.bottom = bottomOffset + 'px';
                  decisionBox.style.top = '';
                  requestAnimationFrame(()=>{ decisionBox.style.opacity = '1'; });
                });
              }

              function startIntegrityCountdown(){
                t0 = performance.now(); // scan “start”
                function loop(now){
                  const elapsed = now - t0;
                  const left = Math.max(0, totalMs - elapsed);
                  renderIntegrity(left);
                  if (left <= 0){
                    timedOut = true;
                    if (decisionBox && decisionBox.classList.contains('expanded')){
                      btnFollow?.click();
                    } else {
                      shouldAutoFollow = true;
                    }
                    return;
                  }
                  rafId = requestAnimationFrame(loop);
                }
                rafId = requestAnimationFrame(loop);
              }



              // Helper: compute door center X and top Y (from already-positioned overlays)
              function doorCenterX(overlayEl){
                const L = parseFloat(overlayEl.style.left)  || 0;
                const W = parseFloat(overlayEl.style.width) || 0;
                return L + W/2;
              }
              function doorTop(overlayEl){
                return parseFloat(overlayEl.style.top) || 0;
              }

              // Run a left→right sweep that ends aimed at the suggested door.
              // Returns a Promise that resolves only after the cone fades out.
              // Deterministic "down → left → right → down" scan (suggestion is ignored here)
              // NOTE: cone apex is *continuously synced* to the drone so they move together.
              function runConeScan({
                frame, droneEl, leftDoorOverlay, rightDoorOverlay,
                bufferMs, preMs = CONFIG.drone_prebuffer_ms
              }) {
                return new Promise((resolve) => {
                  if (!frame || !droneEl || !leftDoorOverlay || !rightDoorOverlay) { resolve(); return; }

                  const frameEl = frame.querySelector('.scene-frame');

                  // door centers (x) and a y target a bit above door mid-height
                  const centerFor = (ov) => {
                    const L = parseFloat(ov.style.left)  || 0;
                    const T = parseFloat(ov.style.top)   || 0;
                    const W = parseFloat(ov.style.width) || 0;
                    const H = parseFloat(ov.style.height)|| 0;
                    return { x: L + W/2, y: T + H*0.25 };
                  };
                  const cL = centerFor(leftDoorOverlay);
                  const cR = centerFor(rightDoorOverlay);

                  // Read config for apex placement
                  const relY  = (CONFIG.cone_apex_rel_y   ?? 0.12);
                  const lift0 = (CONFIG.cone_apex_lift_px ?? 6);
                  const liftK = (CONFIG.cone_apex_lift_ratio ?? 0.08);
                  const dx    = (CONFIG.cone_apex_dx      ?? 0);

                  // Helper: compute current apex under the drone (follows current position)
                  function currentApex() {
                    const frameRect = frameEl.getBoundingClientRect();
                    const droneRect = droneEl.getBoundingClientRect();

                    // center X of the drone in frame coordinates
                    const centerX = (droneRect.left + droneRect.width / 2) - frameRect.left;

                    // pick a point inside the drone box (relY), then lift a bit so it tucks under the chassis
                    const relY  = (CONFIG.cone_apex_rel_y ?? 0.12);
                    const lift0 = (CONFIG.cone_apex_lift_px ?? 6);
                    const liftK = (CONFIG.cone_apex_lift_ratio ?? 0.08);
                    const dx    = (CONFIG.cone_apex_dx ?? 0);

                    const droneH = droneRect.height || parseFloat(droneEl.style.height) || 80;
                    const baseY  = (droneRect.top - frameRect.top) + droneH * relY;
                    const lift   = Math.max(lift0, Math.round(droneH * liftK));

                    return { x: Math.round(centerX) + dx, y: Math.max(0, Math.round(baseY - lift)), h: droneH };
                  }

                  function fromCurrent() {
                    // returns the exact transform matrix the cone is holding *right now*
                    const m = getComputedStyle(cone).transform;
                    return (m && m !== 'none') ? m : 'matrix(1, 0, 0, 1, 0, 0)'; // identity fallback
                  }

                  // 0° is "straight down"
                  const toDeg = (rad) => rad * 180 / Math.PI;
                  const angleFromApexTo = (apex, pt) => {
                    const ddx = pt.x - apex.x;
                    const ddy = pt.y - apex.y; // y down
                    return toDeg(Math.atan2(ddx, ddy));
                  };
                  const unwrapAround = (base, ang) => {
                    let a = ang;
                    while (a - base > 180)  a -= 360;
                    while (a - base < -180) a += 360;
                    return a;
                  };

                  
                  // Defensive: remove any stray cone from earlier (shouldn’t exist per-trial, but safe)
                  const oldCone = frameEl.querySelector('.scan-cone');
                  if (oldCone) oldCone.remove();
                  // Create cone element (we’ll keep updating its apex while animating rotation)
                  const cone = document.createElement('div');
                  cone.className = 'scan-cone';

                  // Initial sizing to span doors and reach them
                  const spanX = Math.abs(cR.x - cL.x);
                  const reach = Math.max(220, Math.min(spanX * 0.9, frameEl.getBoundingClientRect().width * 0.9));
                  const baseW = Math.max(200, Math.min(spanX * 0.75, 520));
                  cone.style.width  = baseW + 'px';
                  cone.style.height = reach + 'px';
                  cone.style.opacity = '0';

                  const grid = document.createElement('div');
                  grid.className = 'grid';
                  cone.appendChild(grid);
                  frameEl.appendChild(cone);

                  // Compute initial angles using the initial apex
                  const apex0 = currentApex();
                  cone.style.left = apex0.x + 'px';
                  cone.style.top  = apex0.y + 'px';

                  const a0 = 0; // straight down
                  const aL0 = unwrapAround(a0, angleFromApexTo(apex0, cL));
                  const aR0 = unwrapAround(a0, angleFromApexTo(apex0, cR));
                  const leftA  = (aL0 <= aR0) ? aL0 : aR0;
                  const rightA = (aL0 <= aR0) ? aR0 : aL0;
                  
                  function rot(deg){ return `translate(-50%, 0) rotate(${deg}deg)`; }

                  function neutralTransform(angle) {
                    // rotation only; no skew/squash/spread
                    return `${rot(angle)} skewX(0deg) scale(1, 1)`;
                  }


                  // Map any angle to a 0..1 “how oblique am I vs straight down?”
                  function obliqueness(angle) {
                    // Normalize by the larger side so left/right extremes are ~1.0
                    const maxD = Math.max(Math.abs(leftA - a0), Math.abs(rightA - a0), 1e-3);
                    return Math.min(1, Math.abs(angle - a0) / maxD);
                  }

                  // Build the transform string with forced perspective terms
                  function perspectiveTransform(angle) {
                    const t = obliqueness(angle);
                    const squash = 1 - t * (CONFIG.cone_persp_max_squash ?? 0.35);   // scaleY
                    const skew   = t * (CONFIG.cone_persp_max_skew_deg ?? 6) * (angle < a0 ? -1 : 1);
                    const spread = 1 + t * (CONFIG.cone_persp_spread_x ?? 0.10);     // scaleX
                    return `${rot(angle)} skewX(${skew}deg) scale(${spread}, ${squash})`;
                  }

                  // A clean, steady dwell that *holds* the forced perspective (no wobble)
                  async function perspectiveDwell(angle, HOLD, cone, grid) {
                    // Small, linear “raster” for the grid to imply active scanning (optional but subtle)
                    const gridPx = 10;
                    const a1 = cone.animate(
                      [{ transform: perspectiveTransform(angle) }, { transform: perspectiveTransform(angle) }],
                      { duration: Math.max(80, HOLD), easing: 'linear', fill: 'forwards' }
                    );
                    const a2 = grid?.animate?.(
                      [{ backgroundPosition: '0 0' }, { backgroundPosition: `0 -${gridPx}px` }],
                      { duration: Math.max(80, HOLD), easing: 'linear', fill: 'forwards' }
                    );
                    await a1.finished.catch(()=>{});
                    await a2?.finished?.catch(()=>{});
                    cone.style.transform = perspectiveTransform(angle);
                  }


                  cone.style.transform = neutralTransform(a0);
                  cone.getBoundingClientRect(); // force layout

                  // Keep apex glued to drone during the entire scan
                  let following = true;
                  function syncApex() {
                    if (!following) return;
                    const ap = currentApex();
                    // Only write when changed to minimize layout thrash
                    if (cone.style.left !== (ap.x + 'px')) cone.style.left = ap.x + 'px';
                    if (cone.style.top  !== (ap.y + 'px')) cone.style.top  = ap.y + 'px';
                    requestAnimationFrame(syncApex);
                  }
                  requestAnimationFrame(syncApex);


                  // 1) APPEAR: fade + grow from apex
                  const appearDur = Math.max(120, preMs);
                  const appear = cone.animate([
                    { opacity: 0, transform: neutralTransform(a0) + ' scaleY(0.6)' },
                    { opacity: 1, transform: neutralTransform(a0) }
                  ], { duration: appearDur, easing: 'cubic-bezier(.25,.9,.2,1)', fill: 'forwards' });

                  // 2) SWEEP with dwells: down → left (wobble) → right (wobble) → down
                  appear.finished.catch(()=>{}).then(async () => {
                    const d1 = Math.abs(leftA  - a0);
                    const d2 = Math.abs(rightA - leftA);
                    const d3 = Math.abs(a0     - rightA);
                    const D  = Math.max(1e-3, d1 + d2 + d3);

                    const HOLD = Math.max(0, CONFIG.cone_dwell_ms ?? 180);
                    const baseBudget = Math.max(300, bufferMs);
                    const moveBudget = Math.max(150, baseBudget - 2 * HOLD);
                    const t1 = moveBudget * (d1 / D);
                    const t2 = moveBudget * (d2 / D);
                    const t3 = moveBudget * (d3 / D);

                    const KICK = Math.min(0.98, Math.max(0.50, CONFIG.cone_persp_kickin ?? 0.82)); // safety clamp

                    // Move: down → left
                    await cone.animate(
                      [
                        { transform: fromCurrent(), offset: 0 }, // <- no jump
                        { transform: neutralTransform(a0 + (leftA - a0) * KICK), offset: KICK },
                        { transform: perspectiveTransform(leftA), offset: 1 }
                      ],
                      { duration: Math.max(60, t1), easing: 'linear', fill: 'forwards' }
                    ).finished.catch(()=>{});

                    // Dwell at left (keep as-is, but ensure it ends exactly on perspective)
                    await perspectiveDwell(leftA, HOLD, cone, grid);

                    // Move: left → right
                    await cone.animate(
                      [
                        { transform: fromCurrent(), offset: 0 }, // <- start from the dwell's end
                        { transform: neutralTransform(leftA + (rightA - leftA) * KICK), offset: KICK },
                        { transform: perspectiveTransform(rightA), offset: 1 }
                      ],
                      { duration: Math.max(60, t2), easing: 'linear', fill: 'forwards' }
                    ).finished.catch(()=>{});

                    // Dwell at right (unchanged)
                    await perspectiveDwell(rightA, HOLD, cone, grid);

                    // Move: right → down
                    await cone.animate(
                      [
                        { transform: fromCurrent(), offset: 0 }, // <- start from right dwell
                        { transform: neutralTransform(rightA + (a0 - rightA) * KICK), offset: KICK },
                        { transform: perspectiveTransform(a0), offset: 1 }
                      ],
                      { duration: Math.max(60, t3), easing: 'linear', fill: 'forwards' }
                    ).finished.catch(()=>{});
                    // --- fade out and resolve like before ---
                    following = false; // stop syncing apex
                    await cone.animate([{opacity:1},{opacity:0}], { duration:150, fill:'forwards' })
                              .finished.catch(()=>{});
                    cone.remove();
                    resolve();
                  });
                });
              }

              // We will enable manual choice handlers only if participant selects "Don't follow"
              let manualKeyHandler = null;
              let onLeftClick = null;
              let onRightClick = null;

              const choose = (side) => {
                if (window.__DISCARD_DATA__ || responded) return;
                responded = true;
                window.__LOCK_FX_LAYOUT__ = true;
                try { if (cleanup) cleanup(); } catch(_) {}

                const choice = side; // 'left'|'right'
                const chosenOverlay = frame.querySelector(`.${choice}-door`);
                const chosenDoorImg = chosenOverlay.querySelector('.door-image');
                const revealed      = frame.querySelector('.' + choice + '-revealed');
                if(revealed) revealed.style.visibility = 'visible';

                const rt = (performance.now() - trialStart) / 1000;

                
                // --- trigger door open (unchanged up to adding class) ---
                chosenDoorImg.getBoundingClientRect();
                chosenDoorImg.classList.add('door-open');

                // Compute transition total time for the door open (fallback-safe)
                function msFromTimeList(str) {
                  if (!str) return 0;
                  return str.split(',').map(s => s.trim())
                    .map(v => v.endsWith('ms') ? parseFloat(v) : parseFloat(v) * 1000)
                    .reduce((a, b) => Math.max(a, b), 0);
                }
                const styles  = getComputedStyle(chosenDoorImg);
                const durMs   = msFromTimeList(styles.transitionDuration);
                const delayMs = msFromTimeList(styles.transitionDelay);
                const doorOpenTotalMs = durMs + delayMs;
               
                // --- Mission Outcome Panel (prepare, but don't show yet) ---
                const ok      = (side === true_location);
                const mp      = frame.querySelector('#mission-panel');
                const mpBadge = frame.querySelector('#mp-badge');
                const mpTitle = frame.querySelector('#mp-title');

                if (mp) {
                  mp.classList.remove('is-success', 'is-fail', 'show');
                  mp.classList.add(ok ? 'is-success' : 'is-fail');
                  mpBadge.textContent = ok ? 'SUCCESS' : 'FAILURE';
                  mpTitle.textContent = ok ? 'Victim Found' : 'No Victim Found';
                }

                
                // While banner shows, send the drone off-screen to the right
                function exitDroneRight(){
                  if (!droneEl) return Promise.resolve();

                  return new Promise(async (resolve) => {
                    // small programmable delay before starting, if desired
                    const delay = (CONFIG.drone_exit_delay_ms || 350);
                    if (delay > 0) await wait(delay);

                    const frameEl   = frame.querySelector('.scene-frame');
                    const frameRect = frameEl.getBoundingClientRect();
                    const cur       = getLT(droneEl);

                    const edgeOffset = (CONFIG.drone_exit_edge_offset_px ?? 10);
                    const targetLeft = Math.round(frameRect.width + edgeOffset);

                    const totalDx    = targetLeft - cur.left;
                    if (totalDx <= 0) { resolve(); return; }

                    // split: a short ease-in accel segment, then long linear cruise
                    const accelFrac  = (CONFIG.drone_exit_accel_frac ?? 0.18); // ~18% distance to accelerate
                    const accelDx    = Math.max(24, Math.round(totalDx * accelFrac));
                    const x1         = cur.left + accelDx;

                    const vAccel     = (CONFIG.drone_exit_accel_speed_px_per_s ?? 360); // “pulling away” speed
                    const vCruise    = (CONFIG.drone_exit_cruise_px_per_s ?? 520);      // steady speed

                    const tIn        = Math.max(220, Math.round(1000 * accelDx / vAccel));        // ≥220 ms
                    const tLin       = Math.max(320, Math.round(1000 * (totalDx - accelDx) / vCruise));

                    // pause hover during exit; keep .hovering attached
                    droneEl.classList.add('paused');

                    await moveTo(droneEl, x1, undefined, tIn, 'cubic-bezier(.4,0,1,1)'); // ease-in
                    await moveTo(droneEl, targetLeft, undefined, tLin, 'linear');

                    resolve();
                  });
                }

                // After door is open + short banner hold, fade to black and end trial
                const bannerHold = (window.CONFIG?.panel_hold_ms ?? 1100);
                const blackoutHold = (window.CONFIG?.blackout_hold_ms ?? 300);
                const postHold = IS_LAST ? 0 : blackoutHold;
                const blackoutText = (window.CONFIG?.blackout_text ?? '');

                const afterOpen = () => {
                  
                  // On the last trial, do NOT show the relocating blackout
                  if (!IS_LAST) {
                    showBlackout(blackoutText);
                  } else {
                    // Make sure no leftover blackout is visible
                    try { hideBlackout(); } catch(_) {}
                  }
                  // Stop FX loop after blackout
                  try {
                    fxStopped = true;
                    if (fxRaf) cancelAnimationFrame(fxRaf);
                  } catch(_){}
                  // small extra hold fully black, then finish trial
                  setTO(() => {
                    const rt = (performance.now() - trialStart) / 1000;
                    const correct = (side === true_location);
                    window._lastOutcome = { correct, rt, choice: side, true_location };
                    // Hide the decision box if still visible
                    try { decisionBox.style.display = 'none'; } catch(_){}
                    // Clean listeners we attached earlier
                    if (manualKeyHandler) window.removeEventListener('keydown', manualKeyHandler);
                    if (onLeftClick)  leftDoorOverlay?.removeEventListener('click', onLeftClick);
                    if (onRightClick) rightDoorOverlay?.removeEventListener('click', onRightClick);

                    jsPsych.finishTrial({
                      choice: side,
                      reaction_time_s: rt,
                      correct,
                      suggestion, // keep logging
                      buffer_ms: (typeof t.buffer_ms === 'number') ? t.buffer_ms : CONFIG.drone_buffer_ms,
                      drone_anim_ms: (typeof CONFIG.drone_anim_ms === 'number') ? CONFIG.drone_anim_ms : null,
                      timed_out: timedOut === true,
                      decision_timeout_ms: (typeof CONFIG.decision_timeout_ms === 'number') ? CONFIG.decision_timeout_ms : null,
                      timer_action: CONFIG.timer_action,
                      is_training: IS_TRAINING,
                      risk_key: t.risk_overrides?.risk_key ?? null,
                      risk_warmth: t.risk_overrides?.warmth ?? null,
                      risk_fire_inward_px: t.risk_overrides?.fire_inward_px ?? null,
                      risk_smoke_inward_px: t.risk_overrides?.smoke_inward_px ?? null,
                      risk_smoke_rise_px: t.risk_overrides?.smoke_rise_px ?? null,
                      decision_timeout_ms_used: (t.risk_overrides?.decision_timeout_ms ?? CONFIG.decision_timeout_ms ?? null),
                      shake_amp_px: t.risk_overrides?.shake_amp_px ?? 0,
                      shake_period_ms: t.risk_overrides?.shake_period_ms ?? null,
                      risk_value: t.risk_overrides?.risk_value ?? null,
                    });
                    if (cleanup) cleanup();
                    if (IS_MOBILE) document.getElementById('mobile-choices').style.display = 'none';
                  }, postHold);
                };


                // Wait for the door-open animation, then hold banner briefly, then blackout
                const totalWait = (doorOpenTotalMs > 0 ? doorOpenTotalMs + 40 : 650);

                const panelDelay = (window.CONFIG?.panel_delay_after_open_ms ?? 200);  // ⬅️ small lag after door opens
                const panelHold  = (window.CONFIG?.panel_hold_ms ?? 1100);             // ⬅️ how long panel stays on-screen

                const exitP = exitDroneRight();

                // After the door-open animation completes...
                setTimeout(() => {
                  // 1) small lag so they see the reveal clearly
                  // Fade out the decision box once the outcome phase starts
                    if (decisionBox) {
                      decisionBox.classList.add('hud-closing');
                      decisionBox.style.pointerEvents = 'none';
                      setTimeout(() => {
                        decisionBox.style.display = 'none';
                      }, 250); // match fade duration (~220ms)
                    }
                  setTimeout(() => {
                    // 2) now show the panel
                    
                    if (mp) mp.classList.add('show');

                    // 3) hold the panel while the drone exits (whichever is longer)
                    Promise.all([
                      exitP,
                      new Promise(r => setTimeout(r, panelHold))
                    ]).then(() => {
                      afterOpen(); // triggers blackout + next trial
                    });

                  }, panelDelay);
                }, totalWait);
              };
                          
              
              // --- Entry: single WAAPI with near-constant start → smooth stop (no 2-phase split) ---
              const startLeft = (-droneW - 30);
              const endLeft   = centerLeft;
              const totalDx   = endLeft - startLeft;

              // pick a nominal cruise speed; duration is based on distance
              const vCruise   = (CONFIG.drone_entry_cruise_px_per_s ?? 460);
              const tMs       = Math.max(280, Math.round(1000 * totalDx / Math.max(1, vCruise)));

              // prepare element (no CSS transitions interfering; pause hover but don't clear transform)
              droneEl.style.transition = 'none';
              droneEl.classList.add('hovering', 'paused');
              droneEl.style.top  = centerTop + 'px';
              droneEl.style.left = startLeft + 'px';

              // integrity timer spans entry + prebuffer + scan + transit + decision
              totalMs = tMs + preMs + scanMs + transit + decide;

              hideBlackout();
              startIntegrityCountdown();

              


              // A cubic-bezier whose initial slope ≈ 1 (matches linear speed at t=0) and final slope = 0 (smooth stop).
              // p1=(.30,.30) ⇒ initial slope ~ 1; p2=(.90,1) ⇒ final slope 0.
              const easeStop = 'cubic-bezier(.3,.3,.9,1)';

              const entryAnim = droneEl.animate(
                [
                  { left: startLeft + 'px', top: centerTop + 'px' },
                  { left: endLeft   + 'px', top: centerTop + 'px' }
                ],
                { duration: tMs, easing: easeStop, fill: 'forwards' }
              );

              entryAnim.finished.catch(()=>{}).then(() => {
                // lock the final position and resume gentle hover
                droneEl.style.left = endLeft + 'px';
                droneEl.style.top  = centerTop + 'px';
                // keep transform base at zero; transforms will represent deltas from left/top
                droneEl.style.setProperty('--tx', '0px');
                droneEl.style.setProperty('--ty', '0px');

                droneEl.classList.remove('paused');
                droneEl.classList.add('hovering');
                // keep transform as-is (we never zeroed it), so no snap
                startScanAfterEntry();
              });
              
              function startScanAfterEntry(){
                const bufferMs = (typeof t.buffer_ms === 'number') ? t.buffer_ms : CONFIG.drone_buffer_ms;

                runConeScan({
                  frame,
                  droneEl,
                  leftDoorOverlay,
                  rightDoorOverlay,
                  suggestion,
                  bufferMs,
                  preMs: CONFIG.drone_prebuffer_ms
                }).then(() => {
                  moveDroneToSuggestedDoor();
                });
              }


              function moveDroneToSuggestedDoor() {
                const targetOverlay = suggestion === 'left' ? leftDoorOverlay : rightDoorOverlay;
                if (!targetOverlay || !droneEl) return;

                const doorCenter = Math.round(doorCenterX(targetOverlay));
                const droneRect  = droneEl.getBoundingClientRect();
                const droneW     = droneRect.width  || parseFloat(droneEl.style.width)  || 120;

                const leftPx     = Math.round(doorCenter - droneW / 2);
                const doorH      = parseFloat(targetOverlay.style.height) || 200;
                const GAP        = Math.max(10, Math.round(doorH * 0.08));
                const ty         = Math.max(10, Math.round(doorTop(targetOverlay) - (droneRect.height || 100) - GAP));

                // duration based on distance + hop speed
                const cur        = getLT(droneEl);
                const dx         = Math.abs(leftPx - cur.left);
                const dy         = Math.abs(ty - cur.top);
                const distPx     = Math.hypot(dx, dy);

                const hopSpeed = (CONFIG.drone_hop_speed_px_per_s ?? 260); // slower default
                const baseMs   = Math.round(1000 * distPx / Math.max(1, hopSpeed));
                const hopMin   = (CONFIG.drone_hop_min_ms ?? 1000);        // slightly higher floor
                const scale    = (CONFIG.drone_hop_duration_scale ?? 1.0);
                const durMs    = Math.max(hopMin, Math.round(baseMs * scale));


                // Do NOT pause hover here; we’re composing with var(--hoverY)
                const AMP = Math.max(2, Math.min(6, Math.round(doorH * 0.03)));
                droneEl.style.setProperty('--hover-amp', AMP + 'px');

                const baseLeft = parseFloat(droneEl.style.left) || 0;
                const baseTop  = parseFloat(droneEl.style.top)  || 0;
                const toX = leftPx - baseLeft;
                const toY = ty     - baseTop;

                return moveTransformTo(droneEl, toX, toY, durMs, 'cubic-bezier(.3,.3,.9,1)').then(() => {                  // After arriving, just continue — hover never stopped, so no step.
                  // Demo mode: no HUD, no choice, no door open or outcome
                  if (IS_DEMO) {
                    const dwell = Math.max(300, (window.CONFIG?.training?.dwell_ms ?? 1200));
                    setTimeout(() => {
                      const text = (window.CONFIG?.training?.blackout_text ?? '');
                      showBlackout(text);
                      const hold = Math.max(250, (window.CONFIG?.blackout_hold_ms ?? 1000));
                      setTimeout(() => {
                        jsPsych.finishTrial({
                          trial_type: 'training_demo',
                          is_training: true,
                          suggestion,
                          true_location
                          // no choice / correctness / RT in demo
                        });
                      }, hold);
                    }, dwell);
                    return; // IMPORTANT: skip all HUD/wiring code below
                  }
                  try {
                    if (!IS_DEMO) {
                      decisionText.textContent = `The drone recommends the ${suggestion} door.`;

                      // 1) show, keep COMPACT for a frame so the fade-in is visible
                      decisionBox.classList.add('hud-show');
                      decisionBox.classList.add('compact');

                      // 2) next frame, force a reflow, then expand with a tiny delay
                      requestAnimationFrame(() => {
                        // optional: add a class that enables staggered child delays
                        decisionBox.classList.add('reveal-stagger');

                        // small delay so the height transition is perceived (30–60ms feels good)
                        setTimeout(() => {
                          decisionBox.classList.remove('compact');
                          decisionBox.classList.add('expanded');
                        }, 50);
                      });

                      // --- wire up decision controls + keyboard now ---
                      function decisionKeys(e){
                        if (responded) return;
                        if (e.key === 'f' || e.key === 'F') btnFollow?.click();
                        if (e.key === 'n' || e.key === 'N') btnIgnore?.click();
                      }
                      window.addEventListener('keydown', decisionKeys, { passive: true });

                      function clearDecisionHandlers(){
                        window.removeEventListener('keydown', decisionKeys);
                      }

                      btnFollow.onclick = () => {
                        clearDecisionHandlers();
                        decisionBox.classList.add('hud-closing');
                        decisionBox.classList.remove('expanded');
                        stopIntegrity();
                        choose(suggestion);                 // follow the drone
                      };

                      btnIgnore.onclick = () => {
                        clearDecisionHandlers();
                        decisionBox.classList.add('hud-closing');
                        decisionBox.classList.remove('expanded');
                        stopIntegrity();
                        choose(suggestion === 'left' ? 'right' : 'left');  // go opposite
                      };

                      // if the countdown already hit zero before the box was expanded
                      if (shouldAutoFollow){
                        shouldAutoFollow = false;
                        // let the box finish its expand transition then trigger
                        setTimeout(() => btnFollow?.click(), 0);
                      }

                      requestAnimationFrame(() => decisionBox.classList.add('hud-show'));
                      decisionBox.classList.remove('compact');
                      decisionBox.classList.add('expanded');
                    }
                  } catch(_) {}
                });
              }

              // cleanup on trial finish (keep your existing pattern)
              const prevFinish = this.on_finish;
              this.on_finish = function(data){
                // restore global FX config after this trial
                try {
                  if (_savedFx) {
                    window.CONFIG.fire_inward_px  = _savedFx.fire_inward_px;
                    window.CONFIG.smoke_inward_px = _savedFx.smoke_inward_px;
                    window.CONFIG.smoke_rise_px   = _savedFx.smoke_rise_px;
                  }
                } catch(_) {}

                if (prevFinish) prevFinish.call(this, data);

                // stop the integrity loop & clear timeouts from this trial
                try { stopIntegrity(); } catch(_){}
                try { pendingTO.forEach(clearTimeout); } catch(_){}
                try { fxStopped = true; if (fxRaf) cancelAnimationFrame(fxRaf); } catch(_){}

                if (!window.__DISCARD_DATA__) logTrialRow(data);
              };
            });
            const el = jsPsych.getDisplayElement();
            if (el && typeof el.focus === 'function') el.focus();
          }
        };
      }

      function pushDoorBlockWithProbes(timeline, trialsForBlock, blockIndex, randFn) {
        // Compute the first insertion point with jitter in [min,max]
        const minEvery = window.CONFIG?.trust_probe_every_min ?? 5;
        const maxEvery = window.CONFIG?.trust_probe_every_max ?? minEvery;
        const nextGap = () => {
          if (minEvery === maxEvery) return minEvery;
          const r = randFn ? randFn() : Math.random();
          return minEvery + Math.floor(r * (maxEvery - minEvery + 1));
        };
        let nextAt = nextGap();
        let count = 0;

        trialsForBlock.forEach((t, idx) => {
          // push the actual door trial
          timeline.push(make_door_trial(t, idx, trialsForBlock.length));
          count++;

          // if we reached the cadence, insert a probe (not at block end unless you want)
          const isLast = (idx === trialsForBlock.length - 1);
          if (count === nextAt && !isLast) {
            // fade up to light → probe → fade back to dark
            timeline.push(makeFadeTransition('light', 200));
            timeline.push(makeTrustProbeTrial(`mid_block${blockIndex}_t${count}`));
            timeline.push(makeFadeTransition({ to: 'dark', fadeIn: false, holdMs: 0 }));

            // schedule next insertion
            nextAt += nextGap();
          }
        });
      }

      // Insert probes at explicit 1-based trial indices (e.g., [5,10,15])
      function pushDoorBlockWithExplicitProbes(timeline, trialsForBlock, blockIndex, explicitProbeIndices) {
        const N = trialsForBlock.length;
        const probeSet = new Set((explicitProbeIndices || []).map(x => Number(x)));

        trialsForBlock.forEach((t, idx) => {
          const trialNum = idx + 1;
          timeline.push(make_door_trial(t, idx, N));

          const isLast = trialNum === N;
          if (probeSet.has(trialNum) && !isLast) {
            timeline.push(makeFadeTransition('light', 200));
            timeline.push(makeTrustProbeTrial(`mid_block${blockIndex}_t${trialNum}`));
            timeline.push(makeFadeTransition({ to: 'dark', fadeIn: false, holdMs: 0 }));
          }
        });
      }


      // === Training (non-interactive demo) ===
      // Build a few “watch only” scenes; no HUD, no choices, no reveal.
      const __TRAIN = generateTrainingTrials(CONFIG.training.n, RAND);

      // Fade to dark once, run the demo scenes, keep dark so we can continue straight into Block 1.
      timeline.push(makeFadeTransition({ to: 'dark', fadeIn: false, holdMs: 0 }));

      __TRAIN.forEach((t, i) => {
        timeline.push(make_door_trial(t, i, __TRAIN.length, { training: true, demo: true }));
      });

      // Optional: brief “Training complete” blackout text between demo and trials.
      // If you want it, keep this next line; otherwise comment it out.
      timeline.push(makeFadeTransition({ to: '#000', holdMs: 300, fadeIn: true }));
      // === End training ===

      async function initExperiment() {
        try {
          // Load chosen set & build blocks
          const { mode, blocks, set_id } = await loadTrialsBlocks();
          blocks.forEach(b => { b.trials = augmentTrials(b.trials); });

          // log assignment
          console.info('[HRI] Assigned set:', set_id, 'Blocks:', blocks.length);

          // Log the assigned set id with your session data
          window.EXP_METADATA = window.EXP_METADATA || {};
          window.EXP_METADATA.assigned_set = set_id;

          // Block 1
          const b1 = blocks[0] || {trials:[], probes:null};
          if (b1.probes && b1.probes.length) {
            pushDoorBlockWithExplicitProbes(timeline, b1.trials, 1, b1.probes);
          } else {
            pushDoorBlockWithProbes(timeline, b1.trials, 1, RAND);
          }

          // First Midpoint: 14-item Questionnaire and Single Trust Probe
          timeline.push(makeFadeTransition('light', 300));
          timeline.push(trust14_trial);
          timeline.push(makeTrustProbeTrial('after_trust14_mid1'));

          // Block 2
          timeline.push(makeFadeTransition({ to: 'dark', fadeIn: false, holdMs: 0 }));
          const b2 = blocks[1] || {trials:[], probes:null};
          if (b2.probes && b2.probes.length) {
            pushDoorBlockWithExplicitProbes(timeline, b2.trials, 2, b2.probes);
          } else {
            pushDoorBlockWithProbes(timeline, b2.trials, 2, RAND);
          }

          // Second Midpoint: 14-item Questionnaire and Single Trust Probe
          timeline.push(makeFadeTransition('light', 300));
          timeline.push(trust14_trial);
          timeline.push(makeTrustProbeTrial('after_trust14_mid2'));

          // Block 3
          timeline.push(makeFadeTransition({ to: 'dark', fadeIn: false, holdMs: 0 }));
          const b3 = blocks[2] || {trials:[], probes:null};
          if (b3.probes && b3.probes.length) {
            pushDoorBlockWithExplicitProbes(timeline, b3.trials, 3, b3.probes);
          } else {
            pushDoorBlockWithProbes(timeline, b3.trials, 3, RAND);
          }
        } catch (err) {
          console.error('Init failed:', err);
          alert('Failed to load condition sets. See console for details.');
        }
      }

      // Build blocks *now* and wait for them before continuing.
      await initExperiment();      

      // Final 40-item Questionnaire and Single Trust Probe
      timeline.push(makeFadeTransition('light', 300));
      timeline.push(trust40_trial);
      timeline.push(makeTrustProbeTrial('after_trust40_post'));

      // Exit UI handlers
      const exitBtn = document.getElementById('exit-btn');
      const exitModal = document.getElementById('exit-modal');
      const btnResume = document.getElementById('exit-resume');
      const btnKeep   = document.getElementById('exit-keep');
      const btnDiscard= document.getElementById('exit-discard');

      exitBtn.onclick = () => showExitModal(jsPsych);
      window.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && (e.key === 'X' || e.key === 'x')) {
          if (exitModal.style.display !== 'flex') showExitModal(jsPsych);
        }
      });

      // Resume
      btnResume.onclick = () => hideExitModal(jsPsych);

      // Exit & keep data
      btnKeep.onclick = () => {
        window.__END_REASON__ = 'keep';
        window.__MANUAL_END__ = true;
        exitModal.style.display = 'none';

        try { if (document.fullscreenElement && document.exitFullscreen) { document.exitFullscreen().catch(()=>{}); } } catch(_){}
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';
        document.body.classList.remove('task-dark');
        window.__MANUAL_END__ = true;          // hard stop flag used by hasEnded()
        try { hideBlackout(); } catch(_) {}     // make sure blackout is gone
        try { document.querySelectorAll('.scan-cone').forEach(n => n.remove()); } catch(_) {}
        try { jsPsych.pluginAPI.clearAllTimeouts?.(); } catch(_) {}  // clears jsPsych-managed timers
        showEndScreenKeep();

        try { jsPsych.pluginAPI.cancelAllKeyboardResponses?.(); } catch(_){}
        try { jsPsych.pluginAPI.clearAllTimeouts?.(); } catch(_){}
        try {
          const rows = buildRowsForLogging(jsPsych.data.get().values());
          logAsync(rows).catch(()=>{});
        } catch(_){}
        try { jsPsych.endExperiment('Ended early (keep data).'); } catch(_) {}
      };

      // Exit & discard data
      btnDiscard.onclick = async () => {
        window.__DISCARD_DATA__ = true;
        window.__END_REASON__ = 'discard';
        window.__MANUAL_END__ = true;
        exitModal.style.display = 'none';

        try { jsPsych.data.reset(); } catch(_){}
        try { await requestDeleteByParticipant(window.PID); } catch(_){}

        try { if (document.fullscreenElement && document.exitFullscreen) { document.exitFullscreen().catch(()=>{}); } } catch(_){}
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';
        document.body.classList.remove('task-dark');
        window.__MANUAL_END__ = true;          // hard stop flag used by hasEnded()
        try { hideBlackout(); } catch(_) {}     // make sure blackout is gone
        try { document.querySelectorAll('.scan-cone').forEach(n => n.remove()); } catch(_) {}
        try { jsPsych.pluginAPI.clearAllTimeouts?.(); } catch(_) {}  // clears jsPsych-managed timers
        showEndScreenDiscard();

        try { jsPsych.pluginAPI.cancelAllKeyboardResponses?.(); } catch(_){}
        try { jsPsych.pluginAPI.clearAllTimeouts?.(); } catch(_){}
        try { jsPsych.endExperiment('Withdrawn (discard data).'); } catch(_) {}
      };

      jsPsych.run(timeline);
    }
    </script>
  </body>
</html>
